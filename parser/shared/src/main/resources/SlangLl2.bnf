/*
 Copyright (c) 2017-2026, Robby, Kansas State University
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

{
  parserClass="org.sireum.lang.parser.SlangParser"

  // Fragment patterns (for reference only, inlined into token regexps below):
  //   LETTER    = [a-zA-Z]
  //   DIGIT     = [0-9]
  //   HEX_DIGIT = [0-9a-fA-F]
  //   OPSYM     = [\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]
  //   IDF       = [a-zA-Z_]([a-zA-Z0-9$]|_(?!OPSYM))*(_OPSYM+)?
  //             = [a-zA-Z_]([a-zA-Z0-9$]|_(?![\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]))*(_[\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]+)?
  //               Uses negative lookahead so `_` followed by OPSYM is captured as operator suffix,
  //               not consumed by the identifier body (e.g., Subst_> matches as one ID token).
  //   IDESC     = `[^\n\r\t]*`
  //   ESC_SEQ   = \\[btnfr"\x27\\]|\\u[0-9a-fA-F]{4}[0-9a-fA-F]?
  //   SPI       = \\[btnfr"\x27\\]|\\u[0-9a-fA-F]{4}[0-9a-fA-F]?|[^\\"$]|\$\$
  //   EXPONENT  = [eE][+-]?[0-9_]+
  //   MSTRF     = ([^\n\r$]|\$\$)*\r?\n  (i.e., MSTRI \r?\n)
  //   MSTRI     = ([^\n\r$]|\$\$)*

  tokens = [
    // Symbols
    ALL        = '∀'
    ARROW      = '=>'
    ASSIGN     = '='
    AT         = '@'
    COMMA      = ','
    COLON      = ':'
    DOT        = '.'
    UNDERSCORE = '_'
    LBRACE     = '{'
    LPAREN     = '('
    LSQUARE    = '['
    STAR       = '*'
    RBRACE     = '}'
    RPAREN     = ')'
    RSQUARE    = ']'
    SEQUENT    = '⊢'
    VDASH      = '|-'
    SOME       = '∃'
    TO         = '..'
    UNTIL      = '..<'
    LANGLE     = '<'
    RANGLE     = '>'
    LRANGLE    = '<>'
    BACKTICK   = '`'
    QUESTION   = '?'

    // Keywords
    CASE       = 'case'
    DEDUCE     = 'deduce'
    DEF        = 'def'
    DO         = 'do'
    FALSE      = 'false'
    ELSE       = 'else'
    FOR        = 'for'
    TYPE       = 'type'
    IF         = 'if'
    IMPORT     = 'import'
    MATCH      = 'match'
    PACKAGE    = 'package'
    RETURN     = 'return'
    SUPER      = 'super'
    THIS       = 'this'
    TRUE       = 'true'
    WHILE      = 'while'
    YIELD      = 'yield'
    VAL        = 'val'
    VAR        = 'var'
    BY         = 'by'
    ASSERT     = 'assert'
    ASSUME     = 'assume'
    HALT       = 'halt'
    NULL       = 'null'

    // Lexer tokens

    // SYMBOL: '\' IDF
    SYMBOL     = 'regexp:\\[a-zA-Z_]([a-zA-Z0-9$]|_(?![\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]))*(_[\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]+)?'

    // STRING: '"' ( ESC_SEQ | ~('\\' | '"') )* '"'
    STRING     = 'regexp:"(\\[btnfr"\x27\\]|\\u[0-9a-fA-F]{4}[0-9a-fA-F]?|[^\\"])*"'

    // SP: IDF '"' SPI* '"'  (complete string interpolation, no $ parts)
    SP         = 'regexp:[a-zA-Z_]([a-zA-Z0-9$]|_(?![\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]))*(_[\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]+)?"(\\[btnfr"\x27\\]|\\u[0-9a-fA-F]{4}[0-9a-fA-F]?|[^\\"$]|\$\$)*"'

    // SPB: IDF '"' SPI* '$'  (string interpolation begin)
    SPB        = 'regexp:[a-zA-Z_]([a-zA-Z0-9$]|_(?![\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]))*(_[\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]+)?"(\\[btnfr"\x27\\]|\\u[0-9a-fA-F]{4}[0-9a-fA-F]?|[^\\"$]|\$\$)*\$'

    // SPM: '$' SPI* '$'  (string interpolation middle)
    SPM        = 'regexp:\$(\\[btnfr"\x27\\]|\\u[0-9a-fA-F]{4}[0-9a-fA-F]?|[^\\"$]|\$\$)*\$'

    // SPE: '$' SPI* '"'  (string interpolation end)
    SPE        = 'regexp:\$(\\[btnfr"\x27\\]|\\u[0-9a-fA-F]{4}[0-9a-fA-F]?|[^\\"$]|\$\$)*"'

    // MSTR: ('#' MSTRF WSF?)* '#' MSTRF  (multiline string)
    MSTR       = 'regexp:(#([^\n\r$]|\$\$)*\r?\n[ \t]*)*#([^\n\r$]|\$\$)*\r?\n'

    // MSTRP: IDF ('#' MSTRF WSF?)* '#' MSTRF  (multiline string interpolation, no $ parts)
    MSTRP      = 'regexp:[a-zA-Z_]([a-zA-Z0-9$]|_(?![\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]))*(_[\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]+)?(#([^\n\r$]|\$\$)*\r?\n[ \t]*)*#([^\n\r$]|\$\$)*\r?\n'

    // MSTRPB: IDF ('#' MSTRF WSF?)* '#' MSTRI '$'  (multiline string interpolation begin)
    MSTRPB     = 'regexp:[a-zA-Z_]([a-zA-Z0-9$]|_(?![\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]))*(_[\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]+)?(#([^\n\r$]|\$\$)*\r?\n[ \t]*)*#([^\n\r$]|\$\$)*\$'

    // MSTRPM: '$' MSTRF WSF? ('#' MSTRF WSF?)* '#' MSTRI '$'  (multiline string interpolation middle)
    MSTRPM     = 'regexp:\$([^\n\r$]|\$\$)*\r?\n[ \t]*(#([^\n\r$]|\$\$)*\r?\n[ \t]*)*#([^\n\r$]|\$\$)*\$'

    // MSTRPE: '$' MSTRF?  (multiline string interpolation end)
    MSTRPE     = 'regexp:\$(([^\n\r$]|\$\$)*\r?\n)?'

    // ID: '\''? IDF | IDESC
    ID         = 'regexp:\x27?[a-zA-Z_]([a-zA-Z0-9$]|_(?![\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]))*(_[\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]+)?|`[^\n\r\t]*`'

    // HLINE: '-----'+
    HLINE      = 'regexp:-{5,}'

    // OP: OPSYM+ | '\' IDF
    OP         = 'regexp:[\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]+|\\[a-zA-Z_]([a-zA-Z0-9$]|_(?![\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]))*(_[\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]+)?'

    // HEX: '0x' HEX_DIGIT ('_' | HEX_DIGIT)*
    HEX        = 'regexp:0x[0-9a-fA-F][_0-9a-fA-F]*'

    // BIN: '0b' ('0'|'1') ('0'|'1'|'_')*
    BIN        = 'regexp:0b[01][01_]*'

    // INT: ('0' | '-'? '1'..'9' (DIGIT|'_')*) (LETTER (IDF | IDESC))?
    INT        = 'regexp:(0|-?[1-9][0-9_]*)([a-zA-Z]([a-zA-Z_]([a-zA-Z0-9$]|_(?![\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]))*(_[\u2200-\u22FF\u2A00-\u2AFF\u27C0-\u27EF\u2980-\u29FF+\-*/%<>!&\^|~:=]+)?|`[^\n\r\t]*`))?'

    // REAL: ('0' | '-'? '1'..'9' (DIGIT|'_')*) ('.' DIGIT (DIGIT|'_')* EXPONENT? | EXPONENT) ('f'|'F'|'d'|'D')?
    REAL       = 'regexp:(0|-?[1-9][0-9_]*)(\.[0-9][0-9_]*([eE][+-]?[0-9_]+)?|[eE][+-]?[0-9_]+)[fFdD]?'

    // CHAR: '\'' (ESC_SEQ | ~('\'' | '\\')) '\''
    CHAR       = 'regexp:\x27(\\[btnfr"\x27\\]|\\u[0-9a-fA-F]{4}[0-9a-fA-F]?|[^\x27\\])\x27'

    // Whitespace and comments (automatically skipped by PsiBuilder)
    WHITE_SPACE = 'regexp:\s+'
    COMMENT     = 'regexp://[^\n\r]*|/\*([^*]|\*[^/])*(\*/?|\*\*/?)'
  ]
}

file ::= program

expFile ::= [annot] exp

stmtFile ::= [annot] stmt

program ::= [annot] imprt* mainMember* pkg*

imprt ::= IMPORT ID [importIdSuffix]

importIdSuffix ::= DOT ( importWildcardSuffix | importQualSuffix | importRenamesSuffix )

importWildcardSuffix ::= UNDERSCORE [annot]

importQualSuffix ::= ID [importIdSuffix]

importRenamesSuffix ::= LBRACE importRename importRenameSuffix* [COMMA] RBRACE

importRenameSuffix ::= COMMA importRename

importRename ::= ID ARROW ID [annot]

mainMember ::= stmt | typeDefn

pkg ::= PACKAGE mod* [name] [annot] imprt* ( member* | pkgSuffix )

pkgSuffix ::= LBRACE mainMember* RBRACE

init ::= DOT DOT LBRACE [annot] stmt* RBRACE

member ::= varDefn | defDefn | typeDefn | init

mod ::= AT ID [LSQUARE args RSQUARE]

args ::= [annot] rhs argSuffix* | namedArg namedArgSuffix*

argSuffix ::= COMMA [annot] rhs

namedArgSuffix ::= COMMA namedArg

namedArg ::= ID ASSIGN [annot] rhs

name ::= ID nameSuffix*

nameSuffix ::= DOT ID

typeDefn ::= TYPE mod* ID [typeParams] [typeDefnEnumSuffix | typeDefnAliasSuffix | typeDefnAdtSuffix]

typeDefnEnumSuffix ::= COLON enumMembers

typeDefnAliasSuffix ::= ASSIGN type

typeDefnAdtSuffix ::= params [supers] [annot] [typeDefnAdtMembers]
                     | supers [annot] [typeDefnAdtMembers]
                     | annot [typeDefnAdtMembers]
                     | typeDefnAdtMembers

typeDefnAdtMembers ::= LBRACE member* RBRACE

typeParams ::= LSQUARE typeParam typeParamSuffix* RSQUARE

typeParamSuffix ::= COMMA typeParam

typeParam ::= mod* ID

enumMembers ::= LBRACE ID commaId* [COMMA] RBRACE

commaId ::= COMMA ID

params ::= LPAREN param commaParams* [COMMA] RPAREN

commaParams ::= COMMA param

param ::= [VAL | VAR] mod* ID COLON [ARROW] type

supers ::= COLON supr commaSuper*

commaSuper ::= COMMA supr

supr ::= [annot] name [typeArgs]

annot ::= AT LSQUARE annotArg* RSQUARE

annotArg ::= ( ID | STRING ) ( exp commaExp* | annotArgNested )

annotArgNested ::= LSQUARE annotArg+ RSQUARE

varDefn ::= ( VAL | VAR ) mod* ID [colonType] [annot] [assignSuffix]

assignSuffix ::= ASSIGN [annot] rhs

defDefn ::= DEF mod* defId [typeParams] [defParams] [defnTypeSuffix] [assignSuffix]

defnTypeSuffix ::= COLON type [annot]

defId ::= ID | OP | SYMBOL

defParams ::= LPAREN defParam [defParamSuffix] [COMMA] RPAREN

defParam ::= mod* ID COLON type

defParamSuffix ::= COMMA ( defParamSuffixVarargs | defParam [defParamSuffix] )

defParamSuffixVarargs ::= TO defParam

stmt ::= expOrAssignStmt | varPattern | ifStmt | whileStmt | forStmt | deduceStmt | matchStmt | defStmt | assertumeStmt

assertumeStmt ::= ( ASSERT | ASSUME ) exp [commaExp]

defStmt ::= DEF mod* defId [typeParams] [defParams] [defnTypeSuffix] [assignSuffix]

expOrAssignStmt ::= idStmt | expStmt | doStmt

idStmt ::= ID [typeArgs] ( access+ [annot] [assignSuffix] | [idStmtSuffix] )

idStmtSuffix ::= annot | assignSuffix | labelSuffix

labelSuffix ::= COLON [annot]

expStmt ::= exp0 access+ [annot] [assignSuffix]

doStmt ::= DO [annot] ( exp | mod* block )

varPattern ::= ( VAL | VAR ) pattern0 [colonType1] ASSIGN [annot] rhs

rhs ::= exp | block | ifStmt | matchStmt

ifStmt ::= IF exp [annot] block [els]

block ::= LBRACE [annot] blockContent RBRACE

blockContent ::= stmt* [ret]

ret ::= ( RETURN | HALT ) [annot] [rhs]

els ::= ELSE ( elsIf | block )

elsIf ::= IF exp [annot] block [els]

whileStmt ::= WHILE exp [annot] block

forStmt ::= FOR forRange commaForRange* block

forRange ::= ( ID | UNDERSCORE ) COLON exp [rangeSuffix] [ifExp] [annot]

commaForRange ::= COMMA forRange

rangeSuffix ::= ( TO | UNTIL ) exp [byExp]

byExp ::= BY exp

commaExp ::= COMMA exp

matchStmt ::= MATCH exp [annot] matchCases

matchCases ::= LBRACE cas+ RBRACE

pattern ::= [annot] ( idTypePattern | pattern0 | wildCardPattern | wildCardSeqPattern )

pattern0 ::= lit | refPattern | patterns | name [patterns] | idNamePattern

refPattern ::= DOT name

idTypePattern ::= ID colonType1

colonType1 ::= COLON type1

idNamePattern ::= ID AT name patterns

wildCardPattern ::= UNDERSCORE [colonType1]

wildCardSeqPattern ::= STAR

patterns ::= LPAREN patternsArg [COMMA] RPAREN

patternsArg ::= pattern commaPattern* | namedPattern commaNamedPattern*

namedPattern ::= ID ASSIGN pattern

commaPattern ::= COMMA pattern

commaNamedPattern ::= COMMA ID ASSIGN pattern

exp ::= exp3 | forExp | defAnon | quant

exp3 ::= exp2 infixSuffix*

infixSuffix ::= infixOp exp2

infixOp ::= OP | SYMBOL | LANGLE | RANGLE | LRANGLE | STAR

exp2 ::= exp1 access* [eta]

eta ::= UNDERSCORE

exp1 ::= [OP] ( exp0 | paren )

exp0 ::= idExp | thisExp | superExp | lit | interp | pureBlock | jsonLit

pureBlock ::= AT LBRACE stmt+ RBRACE

idExp ::= ID [typeArgs]

thisExp ::= THIS

superExp ::= SUPER

access ::= [QUESTION] ( fieldAccess | applyAccess )

fieldAccess ::= DOT ID [typeArgs]

applyAccess ::= LPAREN [args] [COMMA] RPAREN [fn]

fn ::= LBRACE COLON [annot] fnBody RBRACE

fnBody ::= blockContent | cas+

lit ::= TRUE | FALSE | INT | HEX | BIN | REAL | STRING | MSTR

jsonLit ::= BACKTICK ( jsonObject | jsonArray | jsonParen )

jsonParen ::= LPAREN jsonExp RPAREN

json ::= jsonObject | jsonArray | jsonExp

jsonObject ::= LBRACE jsonKeyValue commaJsonKeyValue* [COMMA] RBRACE

jsonKeyValue ::= jsonKey COLON json

jsonKey ::= ID | STRING

commaJsonKeyValue ::= COMMA jsonKeyValue

jsonArray ::= LSQUARE json commaJson [COMMA] RSQUARE

commaJson ::= COMMA json

jsonExp ::= exp | jsonNull

jsonNull ::= NULL

paren ::= LPAREN [annot] parenArgs [COMMA] RPAREN

parenArgs ::= exp [annot] commaExpAnnot* | namedExpAnnot commaNamedExpAnnot*

namedExpAnnot ::= ID ASSIGN exp [annot]

commaExpAnnot ::= COMMA exp [annot]

commaNamedExpAnnot ::= COMMA ID ASSIGN exp [annot]

cas ::= CASE pattern [ifExp] ARROW [annot] blockContent

ifExp ::= IF exp

forExp ::= YIELD [annot] forRange commaForRange* ARROW [annot] rhs

defAnon ::= DEF mod* defParams [colonType] DOT [annot] rhs

colonType ::= COLON type

quant ::= ( ALL | SOME | SYMBOL ) quantRange+ ARROW [annot] rhs

quantRange ::= idComma* ID [annot] COLON [annot] exp [quantRangeSuffix]

idComma ::= ID COMMA

quantRangeSuffix ::= ( TO | UNTIL ) [annot] exp

deduceStmt ::= DEDUCE ( truthTable | proof | sequent+ | expProof )

proof ::= LBRACE proofStep* RBRACE

sequent ::= COLON [exps] ( SEQUENT | VDASH ) exp [proof]

exps ::= exp commaExp*

expProof ::= LPAREN expJustOpt commaExpJustOpt* [COMMA] RPAREN

commaExpJustOpt ::= COMMA expJustOpt

expJustOpt ::= exp [just]

proofStep ::= proofId DOT ( exp just | subProof | assumeProofStep | assertProofStep )

assumeProofStep ::= ASSUME exp

assertProofStep ::= ASSERT exp subProof

subProof ::= LBRACE freshIds* proofStep+ RBRACE

freshIds ::= ID commaId* [colonType]

proofId ::= INT | STRING

just ::= BY name [justTypeArgs] [justArgs] (proofId !DOT)*

justArgs ::= LPAREN args [COMMA] RPAREN

justTypeArgs ::= LSQUARE type commaType* RSQUARE

commaType ::= COMMA type

truthTable ::= STAR+
               HLINE
               ID+ colonExp+
               HLINE
               ID+ colonIds+
               HLINE
               [truthTableConclusion]

colonExp ::= COLON exp

colonIds ::= COLON ID+

truthTableConclusion ::= LSQUARE ID RSQUARE [truthTableCases]

truthTableCases ::= LBRACE truthTableCase* RBRACE

truthTableCase ::= CASE ID ARROW [truthTableAssignments]

truthTableAssignments ::= truthTableAssignment commaTruthTableAssignment*

truthTableAssignment ::= ID+

commaTruthTableAssignment ::= COMMA truthTableAssignment

type ::= type1 typeSuffix*

typeSuffix ::= ARROW [annot] type1

type1 ::= parenType | type0 type0Suffix*

parenType ::= LPAREN typeParenArgs [COMMA] RPAREN

type0Suffix ::= ( OP | SYMBOL ) type0

typeParenArgs ::= [annot] type commaAnnotType* | namedType commaNamedType*

commaAnnotType ::= COMMA [annot] type

namedType ::= ID ASSIGN [annot] type

commaNamedType ::= COMMA ID ASSIGN [annot] type

type0 ::= ID [typeArgs]

typeArgs ::= LSQUARE typeParenArgs RSQUARE

interp ::= SP | SPB sinterp | MSTRP | MSTRPB mstrinterp

sinterp ::= exp ( SPM sinterp | SPE )

mstrinterp ::= exp ( MSTRPM mstrinterp | MSTRPE )
