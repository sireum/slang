// #Sireum
/*
 Copyright (c) 2017-2026,Robby, Kansas State University
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// This file is auto-generated from SlangLl2.g

package org.sireum.lang.parser


import org.sireum._
import org.sireum.U32._
import org.sireum.U64._
import org.sireum.conversions.U32.toC
import org.sireum.parser.ParseTree

object SlangLl2 {
  @range(min = 0, max = 11) class State
}

import SlangLl2.State
import SlangLl2.State._

object SlangLl2Parser {

  @datatype class Result(val kind: Result.Kind.Type, val tree: ParseTree, val newIndex: Z) {
    def leaf: ParseTree.Leaf = {
      return tree.asInstanceOf[ParseTree.Leaf]
    }
  }

  object Result {

    @enum object Kind {
      'Normal
      'LexicalError
      'GrammaticalError
    }

    @strictpure def create(tree: ParseTree, newIndex: Z): Result =
      Result(Result.Kind.Normal, tree, newIndex)

    @strictpure def error(isLexical: B, index: Z): Result =
      Result(if (isLexical) Result.Kind.LexicalError else Result.Kind.GrammaticalError, errorLeaf, index)

  }

  @record class Context(val ruleName: String,
                        val ruleType: U32,
                        val accepting: IS[State, B],
                        var state: State,
                        var resOpt: Option[Result],
                        var j: Z,
                        var max: Z,
                        var initial: B,
                        var trees: ISZ[ParseTree],
                        var found: B,
                        var failIndex: Z,
                        var isLexical: B) {
    def updateAcceptingEpsilon(newState: State): Unit = {
      found = T
      initial = F
      state = newState
      resOpt = Some(Result.create(ParseTree.Node(trees, ruleName, ruleType), j))
    }

    def updateTerminal(token: ParseTree.Leaf, newState: State): Unit = {
      found = T
      j = j + 1
      initial = F
      state = newState
      trees = trees :+ token
      if (accepting(state)) {
        resOpt = Some(Result.create(ParseTree.Node(trees, ruleName, ruleType), j))
      }
    }

    def updateNonTerminal(r: Result, newState: State): Unit = {
      found = T
      initial = F
      j = r.newIndex
      state = newState
      trees = trees :+ r.tree
      if (accepting(state)) {
        resOpt = Some(Result.create(ParseTree.Node(trees, ruleName, ruleType), j))
      }
    }
  }

  object Context {
    @pure def create(ruleName: String, ruleType: U32, accepts: ISZ[State], i: Z): Context = {
      val accepting = MS.create[State, B](12, F)
      for (accept <- accepts) {
        accepting(accept) = T
      }
      return Context(
        ruleName = ruleName,
        ruleType = ruleType,
        accepting = accepting.toIS,
        state = state"0",
        resOpt = None(),
        trees = ISZ[ParseTree](),
        j = i,
        max = i,
        initial = T,
        found = F,
        failIndex = 0,
        isLexical = F
      )
    }
  }

  @record class LContext(val accepting: IS[State, B], var state: State, var j: Z, var afterAcceptIndex: Z, var found: B) {
    def update(newState: State): Unit = {
      state = newState
      found = T
      if (accepting(state)) {
        afterAcceptIndex = j + 1
      }
    }
  }

  object LContext {
    @pure def create(accepts: ISZ[State], i: Z): LContext = {
      val accepting = MS.create[State, B](12, F)
      for (accept <- accepts) {
        accepting(accept) = T
      }
      return LContext(accepting = accepting.toIS, state = state"0", j = i, afterAcceptIndex = -1, found = F)
    }
  }

  @datatype class IndexableToken(val input: Indexable.Pos[C], val skipHidden: B) extends Indexable[Result] {
    val lexer: SlangLl2Lexer = SlangLl2Lexer(input)

    override def at(i: Z): Result = {
      return _at(i)
    }

    override def has(i: Z): B = {
      return _has(i)
    }

    @memoize def _has(i: Z): B = {
      assert(i >= 0)
      if (i == 0) {
        return T
      }
      if (!_has(i - 1)) {
        return F
      }
      val prev = _at(i - 1)
      return prev.kind == Result.Kind.Normal && prev.newIndex != -1
    }

    @memoize def _at(i: Z): Result = {
      if (i == 0) {
        if (input.has(0)) {
          lexer.tokenize(0, skipHidden) match {
            case Some(result) => return result
            case _ =>
          }
        }
      } else {
        val prev = _at(i - 1)
        if (input.has(prev.newIndex)) {
          lexer.tokenize(prev.newIndex, skipHidden) match {
            case Some(result) => return result
            case _ =>
          }
        }
      }
      return Result(Result.Kind.Normal, eofLeaf, -1)
    }

  }

  val kind: String = "SlangLl2Parser"

  val minChar: C = '\u0000'
  val maxChar: C = toC(u32"0x0010FFFF")

  val T_ALL: U32 = u32"0x8F29683F"
  val T_ARROW: U32 = u32"0x203A34BF"
  val T_ASSIGN: U32 = u32"0xF20A2856"
  val T_AT: U32 = u32"0xD735687B"
  val T_COMMA: U32 = u32"0x37DDEF83"
  val T_COLON: U32 = u32"0x54FAE327"
  val T_DOT: U32 = u32"0x9A468353"
  val T_UNDERSCORE: U32 = u32"0xF0D3D2C8"
  val T_LBRACE: U32 = u32"0xDC2A8959"
  val T_LPAREN: U32 = u32"0x643EF7CD"
  val T_LSQUARE: U32 = u32"0x951E9CFB"
  val T_STAR: U32 = u32"0x7EF5EC39"
  val T_RBRACE: U32 = u32"0xED041C82"
  val T_RPAREN: U32 = u32"0xA5073992"
  val T_RSQUARE: U32 = u32"0xA97171F1"
  val T_SEQUENT: U32 = u32"0x611F05DC"
  val T_SOME: U32 = u32"0xC21A525C"
  val T_TO: U32 = u32"0xAB02A212"
  val T_UNTIL: U32 = u32"0x4F158144"
  val T_LANGLE: U32 = u32"0x5ADD78B7"
  val T_RANGLE: U32 = u32"0x01420030"
  val T_LRANGLE: U32 = u32"0x15503F3A"
  val T_BACKTICK: U32 = u32"0x26334490"
  val T_QUESTION: U32 = u32"0xA4512A72"
  val T_ASSUME: U32 = u32"0x02C3896F"
  val T_ASSERT: U32 = u32"0xF5079A9D"
  val T_BY: U32 = u32"0xA7E1A028"
  val T_CASE: U32 = u32"0x186E11D7"
  val T_DEDUCE: U32 = u32"0x0FBD9BE6"
  val T_DEF: U32 = u32"0xCE1D1E69"
  val T_DO: U32 = u32"0x1E045002"
  val T_FALSE: U32 = u32"0x43340E3B"
  val T_ELSE: U32 = u32"0x04DDB5EF"
  val T_FOR: U32 = u32"0xBF5AD766"
  val T_IF: U32 = u32"0x8210408E"
  val T_IMPORT: U32 = u32"0x4B242DB4"
  val T_MATCH: U32 = u32"0x142AC92F"
  val T_PACKAGE: U32 = u32"0x918F5BDB"
  val T_RETURN: U32 = u32"0xD3E917DC"
  val T_SUPER: U32 = u32"0x136381C3"
  val T_THIS: U32 = u32"0x93DEEB98"
  val T_TRUE: U32 = u32"0xEE99A672"
  val T_TYPE: U32 = u32"0x702A655E"
  val T_WHILE: U32 = u32"0x0E0F65B7"
  val T_YIELD: U32 = u32"0x49425B4A"
  val T_VAR: U32 = u32"0x18F352F5"
  val T_HALT: U32 = u32"0x37F385AB"
  val T_NULL: U32 = u32"0x6C774BA6"
  val T_SYMBOL: U32 = u32"0xFA31AB98"
  val T_STRING: U32 = u32"0xA7CF0FE0"
  val T_SP: U32 = u32"0x2C97C56A"
  val T_SPB: U32 = u32"0x50C3B99F"
  val T_SPM: U32 = u32"0xFBA828F9"
  val T_SPE: U32 = u32"0x744EF85A"
  val T_MSTR: U32 = u32"0x84A54E6B"
  val T_MSTRP: U32 = u32"0x7E667FD0"
  val T_MSTRPB: U32 = u32"0x2427C288"
  val T_MSTRPM: U32 = u32"0x6B6A7ADC"
  val T_MSTRPE: U32 = u32"0x537B19CD"
  val T_ID: U32 = u32"0x0FA8D2E6"
  val T_HLINE: U32 = u32"0x7566CFCC"
  val T_OP: U32 = u32"0x3D594292"
  val T_HEX: U32 = u32"0x5028A536"
  val T_BIN: U32 = u32"0x4E33B13F"
  val T_INT: U32 = u32"0x589C233C"
  val T_REAL: U32 = u32"0x1F9A2C24"
  val T_CHAR: U32 = u32"0xE95F063A"
  val T_COMMENT: U32 = u32"0x486B464F"
  val T_WS: U32 = u32"0x0E3F5D1E"
  val T_file: U32 = u32"0x31351F54"
  val T_expFile: U32 = u32"0xD07C5A87"
  val T_stmtFile: U32 = u32"0xEED26BF0"
  val T_program: U32 = u32"0x2CCACB0F"
  val T_imprt: U32 = u32"0xA26F0254"
  val T_importIdSuffix: U32 = u32"0x8449ECF5"
  val T_importWildcardSuffix: U32 = u32"0x11B5CA2D"
  val T_importQualSuffix: U32 = u32"0x04BCDBDF"
  val T_importRenamesSuffix: U32 = u32"0xD10BD008"
  val T_importRenameSuffix: U32 = u32"0xEF507477"
  val T_importRename: U32 = u32"0xC049FF97"
  val T_mainMember: U32 = u32"0x25DD728D"
  val T_pkg: U32 = u32"0x8580997E"
  val T_pkgSuffix: U32 = u32"0xBFFA68BC"
  val T_init: U32 = u32"0x1A10A146"
  val T_member: U32 = u32"0xABC12264"
  val T_mod: U32 = u32"0x26F53763"
  val T_args: U32 = u32"0xCBC52754"
  val T_argSuffix: U32 = u32"0x5C642B6B"
  val T_namedArgSuffix: U32 = u32"0x2E9E692F"
  val T_namedArg: U32 = u32"0xAD932EE4"
  val T_name: U32 = u32"0x859CBD19"
  val T_nameSuffix: U32 = u32"0xB07122CA"
  val T_typeDefn: U32 = u32"0xE2EEB46A"
  val T_typeDefnEnumSuffix: U32 = u32"0xFE5EEC1B"
  val T_typeDefnAliasSuffix: U32 = u32"0x1955C4F8"
  val T_typeDefnAdtSuffix: U32 = u32"0x1BBC16DC"
  val T_typeDefnAdtMembers: U32 = u32"0xD5E5A5A2"
  val T_typeParams: U32 = u32"0x2638F04D"
  val T_typeParamSuffix: U32 = u32"0x568502F3"
  val T_typeParam: U32 = u32"0x698E1A88"
  val T_enumMembers: U32 = u32"0xB2C695F2"
  val T_commaId: U32 = u32"0x830C448A"
  val T_params: U32 = u32"0x781C82F4"
  val T_commaParams: U32 = u32"0x99EB5414"
  val T_param: U32 = u32"0x35B1E2B1"
  val T_supers: U32 = u32"0x65290CBC"
  val T_commaSuper: U32 = u32"0x7A5BA01F"
  val T_supr: U32 = u32"0x71494F9F"
  val T_annot: U32 = u32"0x6937F43D"
  val T_annotArg: U32 = u32"0x0566A2B0"
  val T_annotArgNested: U32 = u32"0xF5187864"
  val T_varDefn: U32 = u32"0xB785E355"
  val T_assignSuffix: U32 = u32"0x1C4C8745"
  val T_defDefn: U32 = u32"0x3CD319B2"
  val T_defnTypeSuffix: U32 = u32"0xEA1E4B25"
  val T_defId: U32 = u32"0xCD1D03AC"
  val T_defParams: U32 = u32"0x8F462218"
  val T_defParam: U32 = u32"0xC60FF6EE"
  val T_defParamSuffix: U32 = u32"0xD51299CB"
  val T_defParamSuffixVarargs: U32 = u32"0x7AADB0A9"
  val T_stmt: U32 = u32"0x24B372D3"
  val T_assertumeStmt: U32 = u32"0x7499B4CD"
  val T_defStmt: U32 = u32"0x8EDAF169"
  val T_expOrAssignStmt: U32 = u32"0x4CD7042C"
  val T_idStmt: U32 = u32"0xB8C111E8"
  val T_idStmtSuffix: U32 = u32"0x82D2F277"
  val T_labelSuffix: U32 = u32"0x983111BB"
  val T_expStmt: U32 = u32"0xD676DC40"
  val T_doStmt: U32 = u32"0xBC8FD161"
  val T_varPattern: U32 = u32"0x4A56733D"
  val T_rhs: U32 = u32"0xF0297F27"
  val T_ifStmt: U32 = u32"0x72C6B874"
  val T_block: U32 = u32"0xAA25218B"
  val T_blockContent: U32 = u32"0x41D34A85"
  val T_ret: U32 = u32"0x618263BA"
  val T_els: U32 = u32"0x83C72679"
  val T_elsIf: U32 = u32"0x334E59A9"
  val T_whileStmt: U32 = u32"0x5D05CC86"
  val T_forStmt: U32 = u32"0xF5A239EA"
  val T_forRange: U32 = u32"0xF6BB1EA0"
  val T_commaForRange: U32 = u32"0x4A80BD07"
  val T_rangeSuffix: U32 = u32"0x53B50CBD"
  val T_byExp: U32 = u32"0x987D502D"
  val T_commaExp: U32 = u32"0x2393742F"
  val T_matchStmt: U32 = u32"0xB29ABF0D"
  val T_matchCases: U32 = u32"0x932AE827"
  val T_pattern: U32 = u32"0x23DEC431"
  val T_pattern0: U32 = u32"0xFF4270E2"
  val T_refPattern: U32 = u32"0xD0388A02"
  val T_idTypePattern: U32 = u32"0x51AD0D88"
  val T_colonType1: U32 = u32"0x4F6B0B02"
  val T_idNamePattern: U32 = u32"0x6AB5150F"
  val T_wildCardPattern: U32 = u32"0xDC465F5F"
  val T_wildCardSeqPattern: U32 = u32"0xD71972DE"
  val T_patterns: U32 = u32"0xE923061E"
  val T_patternsArg: U32 = u32"0x1DC061F8"
  val T_namedPattern: U32 = u32"0x51B5ECF0"
  val T_commaPattern: U32 = u32"0x464D1AE1"
  val T_commaNamedPattern: U32 = u32"0x576742FA"
  val T_exp: U32 = u32"0xC2D3BB33"
  val T_exp3: U32 = u32"0x7690967A"
  val T_infixSuffix: U32 = u32"0x3C3E78A2"
  val T_infixOp: U32 = u32"0xF1501FF2"
  val T_exp2: U32 = u32"0x49E21648"
  val T_eta: U32 = u32"0x08E04CF9"
  val T_exp1: U32 = u32"0x6ADDFAF7"
  val T_exp0: U32 = u32"0xC0DFDD8F"
  val T_pureBlock: U32 = u32"0x2BB3F8B4"
  val T_idExp: U32 = u32"0xFAE4B488"
  val T_thisExp: U32 = u32"0xD728CFA1"
  val T_superExp: U32 = u32"0x51E4C72C"
  val T_access: U32 = u32"0x1037F1F6"
  val T_fieldAccess: U32 = u32"0x0C4BEC0F"
  val T_applyAccess: U32 = u32"0xA72827F7"
  val T_fn: U32 = u32"0xA0B7F904"
  val T_fnBody: U32 = u32"0xE8837734"
  val T_lit: U32 = u32"0x120C7129"
  val T_jsonLit: U32 = u32"0xD2D8A853"
  val T_jsonParen: U32 = u32"0x02ABB62F"
  val T_json: U32 = u32"0x68E8F0CA"
  val T_jsonObject: U32 = u32"0x602986A3"
  val T_jsonKeyValue: U32 = u32"0x5D508F79"
  val T_jsonKey: U32 = u32"0x938F5F0E"
  val T_commaJsonKeyValue: U32 = u32"0xCDF9EEB7"
  val T_jsonArray: U32 = u32"0x3DE8E515"
  val T_commaJson: U32 = u32"0x2C2B5AF4"
  val T_jsonExp: U32 = u32"0x9B278986"
  val T_jsonNull: U32 = u32"0x4EB9C629"
  val T_paren: U32 = u32"0x1920CA8B"
  val T_parenArgs: U32 = u32"0x7845A329"
  val T_namedExpAnnot: U32 = u32"0x10535E6E"
  val T_commaExpAnnot: U32 = u32"0x884BA8BC"
  val T_commaNamedExpAnnot: U32 = u32"0x619A7F97"
  val T_cas: U32 = u32"0xCD3E833F"
  val T_ifExp: U32 = u32"0x57FDC848"
  val T_forExp: U32 = u32"0x67C866A4"
  val T_defAnon: U32 = u32"0x22372D74"
  val T_colonType: U32 = u32"0x7E03BF28"
  val T_quant: U32 = u32"0x98B4E485"
  val T_quantRange: U32 = u32"0x1598B059"
  val T_idComma: U32 = u32"0x90358A28"
  val T_quantRangeSuffix: U32 = u32"0xA6562E8A"
  val T_deduceStmt: U32 = u32"0x79CB0F51"
  val T_proof: U32 = u32"0xD0DAAF2D"
  val T_sequent: U32 = u32"0x625521E7"
  val T_exps: U32 = u32"0xBFC098D4"
  val T_expProof: U32 = u32"0xB02F2234"
  val T_commaExpJustOpt: U32 = u32"0x65AF1FE5"
  val T_expJustOpt: U32 = u32"0x2D0279C1"
  val T_proofStep: U32 = u32"0xBF1A59A9"
  val T_assumeProofStep: U32 = u32"0x3EC27540"
  val T_assertProofStep: U32 = u32"0xE32BE384"
  val T_subProof: U32 = u32"0x84258BED"
  val T_freshIds: U32 = u32"0x34A17B69"
  val T_proofId: U32 = u32"0xC363DAF8"
  val T_just: U32 = u32"0x856B2739"
  val T_justArgs: U32 = u32"0x457AC9A1"
  val T_justTypeArgs: U32 = u32"0x712E6404"
  val T_commaType: U32 = u32"0x3180635B"
  val T_truthTable: U32 = u32"0xC179AFB9"
  val T_colonExp: U32 = u32"0xA8874083"
  val T_colonIds: U32 = u32"0xA76DAE7A"
  val T_truthTableConclusion: U32 = u32"0xC72BB027"
  val T_truthTableCases: U32 = u32"0xE271CB91"
  val T_truthTableCase: U32 = u32"0xF0530019"
  val T_truthTableAssignments: U32 = u32"0x178F54F3"
  val T_truthTableAssignment: U32 = u32"0xA380A72D"
  val T_commaTruthTableAssignment: U32 = u32"0x49357CCB"
  val T_type: U32 = u32"0xE15F8144"
  val T_typeSuffix: U32 = u32"0x57CAFABA"
  val T_type1: U32 = u32"0x7C9A94B9"
  val T_parenType: U32 = u32"0xA2D5F02B"
  val T_type0Suffix: U32 = u32"0x5DB0F761"
  val T_typeParenArgs: U32 = u32"0x05831076"
  val T_commaAnnotType: U32 = u32"0xBE6C19DE"
  val T_namedType: U32 = u32"0xABA54F32"
  val T_commaNamedType: U32 = u32"0x515022D9"
  val T_type0: U32 = u32"0xC89E4B29"
  val T_typeArgs: U32 = u32"0x5C896FFC"
  val T_interp: U32 = u32"0x99E5082E"
  val T_sinterp: U32 = u32"0x3A86312D"
  val T_mstrinterp: U32 = u32"0xC24C785B"

  val errorLeaf: ParseTree.Leaf = ParseTree.Leaf("<ERROR>", "<ERROR>", u32"0xE3CDEDDA", F, None())
  val eofLeaf: ParseTree.Leaf = ParseTree.Leaf("<EOF>", "EOF", u32"0xFC5CB374", F, None())

  def parse(uriOpt: Option[String], input: String, reporter: message.Reporter): Option[ParseTree] = {
    val docInfo = message.DocInfo.create(uriOpt, input)
    val tokens = lex(input, docInfo, T, T, reporter)
    if (reporter.hasError) {
      return None()
    }
    val r = SlangLl2Parser(Indexable.fromIsz(tokens)).parseFile(0)
    r.kind match {
      case Result.Kind.Normal => return Some(r.tree)
      case Result.Kind.LexicalError =>
        reporter.error(Some(message.PosInfo(docInfo, offsetLength(r.newIndex, 1))), kind, s"Could not recognize token")
        return None()
      case Result.Kind.GrammaticalError =>
        val idx: Z = if (r.newIndex < 0) -r.newIndex else r.newIndex
        if (idx < tokens.size) {
          val token = tokens(idx).leaf
          reporter.error(token.posOpt, kind, s"Could not parse token: \"${ops.StringOps(token.text).escapeST.render}\"")
        } else {
          val token = tokens(idx - 1).leaf
          reporter.error(token.posOpt, kind, "Expecting more input but reached the end")
        }
        return None()
    }
  }

  def parseIndexable(input: Indexable.Pos[C], reporter: message.Reporter): Option[ParseTree] = {
    val it = IndexableToken(input, T)
    val r = SlangLl2Parser(it).parseFile(0)
    r.kind match {
      case Result.Kind.Normal => return Some(r.tree)
      case Result.Kind.LexicalError =>
        reporter.error(input.posOpt(r.newIndex, 1), kind, s"Could not recognize token")
        return None()
      case Result.Kind.GrammaticalError =>
        val idx: Z = if (r.newIndex < 0) -r.newIndex else r.newIndex
        if (it.has(idx)) {
          val token = it.at(idx).leaf
          reporter.error(token.posOpt, kind, s"Could not parse token: \"${ops.StringOps(token.text).escapeST.render}\"")
        } else {
          val token = it.at(idx - 1).leaf
          reporter.error(token.posOpt, kind, "Expecting more input but reached the end")
        }
        return None()
    }
  }

  def lex(input: String, docInfo: message.DocInfo, skipHidden: B, stopAtError: B,
          reporter: message.Reporter): ISZ[Result] = {
    return SlangLl2Lexer(Indexable.fromIszDocInfo(conversions.String.toCis(input), docInfo)).tokenizeAll(skipHidden, stopAtError, reporter)
  }

  @pure def offsetLength(offset: Z, length: Z): U64 = {
    return (conversions.Z.toU64(offset) << u64"32") | (conversions.Z.toU64(length) & u64"0xFFFFFFFF")
  }

}

import SlangLl2Parser._

@datatype class SlangLl2Parser(tokens: Indexable[Result]) {

  @pure def parseFile(i: Z): Result = {
    val ctx = Context.create("file", u32"0x31351F54", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_program = predictProgram(ctx.j)
          if (n_program >= 0 && parseProgramH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0xFC5CB374" /* EOF */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseExpFile(i: Z): Result = {
    val ctx = Context.create("expFile", u32"0xD07C5A87", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_exp = predictExp(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_exp == n && parseExpH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0xFC5CB374" /* EOF */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseStmtFile(i: Z): Result = {
    val ctx = Context.create("stmtFile", u32"0xEED26BF0", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_stmt = predictStmt(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_stmt == n && parseStmtH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_stmt = predictStmt(ctx.j)
          if (n_stmt >= 0 && parseStmtH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0xFC5CB374" /* EOF */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseProgram(i: Z): Result = {
    val ctx = Context.create("program", u32"0x2CCACB0F", ISZ(state"0", state"1", state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_imprt = predictImprt(ctx.j)
          val n_mainMember = predictMainMember(ctx.j)
          val n_pkg = predictPkg(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_imprt == n && parseImprtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_mainMember == n && parseMainMemberH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_pkg == n && parsePkgH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            ctx.updateAcceptingEpsilon(state"0")
            return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_imprt = predictImprt(ctx.j)
          val n_mainMember = predictMainMember(ctx.j)
          val n_pkg = predictPkg(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_imprt == n && parseImprtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_mainMember == n && parseMainMemberH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_pkg == n && parsePkgH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_mainMember = predictMainMember(ctx.j)
          val n_pkg = predictPkg(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_mainMember == n && parseMainMemberH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_pkg == n && parsePkgH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_pkg = predictPkg(ctx.j)
          if (n_pkg >= 0 && parsePkgH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseImprt(i: Z): Result = {
    val ctx = Context.create("imprt", u32"0xA26F0254", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x4B242DB4" /* IMPORT */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_importIdSuffix = predictImportIdSuffix(ctx.j)
          if (n_importIdSuffix >= 0 && parseImportIdSuffixH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseImportIdSuffix(i: Z): Result = {
    val ctx = Context.create("importIdSuffix", u32"0x8449ECF5", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x9A468353" /* DOT */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_importWildcardSuffix = predictImportWildcardSuffix(ctx.j)
          val n_importQualSuffix = predictImportQualSuffix(ctx.j)
          val n_importRenamesSuffix = predictImportRenamesSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_importWildcardSuffix == n && parseImportWildcardSuffixH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_importQualSuffix == n && parseImportQualSuffixH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_importRenamesSuffix == n && parseImportRenamesSuffixH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseImportWildcardSuffix(i: Z): Result = {
    val ctx = Context.create("importWildcardSuffix", u32"0x11B5CA2D", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF0D3D2C8" /* UNDERSCORE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          if (n_annot >= 0 && parseAnnotH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseImportQualSuffix(i: Z): Result = {
    val ctx = Context.create("importQualSuffix", u32"0x04BCDBDF", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_importIdSuffix = predictImportIdSuffix(ctx.j)
          if (n_importIdSuffix >= 0 && parseImportIdSuffixH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseImportRenamesSuffix(i: Z): Result = {
    val ctx = Context.create("importRenamesSuffix", u32"0xD10BD008", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_importRename = predictImportRename(ctx.j)
          if (n_importRename >= 0 && parseImportRenameH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_importRenameSuffix = predictImportRenameSuffix(ctx.j)
          if (n_importRenameSuffix >= 0 && parseImportRenameSuffixH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"3")
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseImportRenameSuffix(i: Z): Result = {
    val ctx = Context.create("importRenameSuffix", u32"0xEF507477", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_importRename = predictImportRename(ctx.j)
          if (n_importRename >= 0 && parseImportRenameH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseImportRename(i: Z): Result = {
    val ctx = Context.create("importRename", u32"0xC049FF97", ISZ(state"3", state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x203A34BF" /* ARROW */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          if (n_annot >= 0 && parseAnnotH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseMainMember(i: Z): Result = {
    val ctx = Context.create("mainMember", u32"0x25DD728D", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_stmt = predictStmt(ctx.j)
          val n_typeDefn = predictTypeDefn(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_stmt == n && parseStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_typeDefn == n && parseTypeDefnH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parsePkg(i: Z): Result = {
    val ctx = Context.create("pkg", u32"0x8580997E", ISZ(state"1", state"2", state"3", state"4", state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x918F5BDB" /* PACKAGE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_mod = predictMod(ctx.j)
          val n_name = predictName(ctx.j)
          val n_annot = predictAnnot(ctx.j)
          val n_imprt = predictImprt(ctx.j)
          val n_member = predictMember(ctx.j)
          val n_pkgSuffix = predictPkgSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_mod == n && parseModH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_name == n && parseNameH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_imprt == n && parseImprtH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_member == n && parseMemberH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_pkgSuffix == n && parsePkgSuffixH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_imprt = predictImprt(ctx.j)
          val n_member = predictMember(ctx.j)
          val n_pkgSuffix = predictPkgSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_imprt == n && parseImprtH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_member == n && parseMemberH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_pkgSuffix == n && parsePkgSuffixH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_imprt = predictImprt(ctx.j)
          val n_member = predictMember(ctx.j)
          val n_pkgSuffix = predictPkgSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_imprt == n && parseImprtH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_member == n && parseMemberH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_pkgSuffix == n && parsePkgSuffixH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_member = predictMember(ctx.j)
          if (n_member >= 0 && parseMemberH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parsePkgSuffix(i: Z): Result = {
    val ctx = Context.create("pkgSuffix", u32"0xBFFA68BC", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_mainMember = predictMainMember(ctx.j)
          if (n_mainMember >= 0 && parseMainMemberH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"2")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseInit(i: Z): Result = {
    val ctx = Context.create("init", u32"0x1A10A146", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xAB02A212" /* TO */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_stmt = predictStmt(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_stmt == n && parseStmtH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_stmt = predictStmt(ctx.j)
          if (n_stmt >= 0 && parseStmtH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseMember(i: Z): Result = {
    val ctx = Context.create("member", u32"0xABC12264", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_varDefn = predictVarDefn(ctx.j)
          val n_defDefn = predictDefDefn(ctx.j)
          val n_typeDefn = predictTypeDefn(ctx.j)
          val n_init = predictInit(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_varDefn == n && parseVarDefnH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defDefn == n && parseDefDefnH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_typeDefn == n && parseTypeDefnH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_init == n && parseInitH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseMod(i: Z): Result = {
    val ctx = Context.create("mod", u32"0x26F53763", ISZ(state"2", state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xD735687B" /* AT */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x951E9CFB" /* LSQUARE */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_args = predictArgs(ctx.j)
          if (n_args >= 0 && parseArgsH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA97171F1" /* RSQUARE */ => ctx.updateTerminal(token, state"5")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseArgs(i: Z): Result = {
    val ctx = Context.create("args", u32"0xCBC52754", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_rhs = predictRhs(ctx.j)
          val n_namedArg = predictNamedArg(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_rhs == n && parseRhsH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_namedArg == n && parseNamedArgH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_rhs = predictRhs(ctx.j)
          if (n_rhs >= 0 && parseRhsH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_argSuffix = predictArgSuffix(ctx.j)
          if (n_argSuffix >= 0 && parseArgSuffixH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_namedArgSuffix = predictNamedArgSuffix(ctx.j)
          if (n_namedArgSuffix >= 0 && parseNamedArgSuffixH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseArgSuffix(i: Z): Result = {
    val ctx = Context.create("argSuffix", u32"0x5C642B6B", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_rhs = predictRhs(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_rhs == n && parseRhsH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_rhs = predictRhs(ctx.j)
          if (n_rhs >= 0 && parseRhsH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseNamedArgSuffix(i: Z): Result = {
    val ctx = Context.create("namedArgSuffix", u32"0x2E9E692F", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_namedArg = predictNamedArg(ctx.j)
          if (n_namedArg >= 0 && parseNamedArgH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseNamedArg(i: Z): Result = {
    val ctx = Context.create("namedArg", u32"0xAD932EE4", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF20A2856" /* ASSIGN */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_rhs = predictRhs(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_rhs == n && parseRhsH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_rhs = predictRhs(ctx.j)
          if (n_rhs >= 0 && parseRhsH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseName(i: Z): Result = {
    val ctx = Context.create("name", u32"0x859CBD19", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_nameSuffix = predictNameSuffix(ctx.j)
          if (n_nameSuffix >= 0 && parseNameSuffixH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseNameSuffix(i: Z): Result = {
    val ctx = Context.create("nameSuffix", u32"0xB07122CA", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x9A468353" /* DOT */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTypeDefn(i: Z): Result = {
    val ctx = Context.create("typeDefn", u32"0xE2EEB46A", ISZ(state"2", state"3", state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x702A655E" /* TYPE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_mod = predictMod(ctx.j)
          if (n_mod >= 0 && parseModH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_typeParams = predictTypeParams(ctx.j)
          val n_typeDefnEnumSuffix = predictTypeDefnEnumSuffix(ctx.j)
          val n_typeDefnAliasSuffix = predictTypeDefnAliasSuffix(ctx.j)
          val n_typeDefnAdtSuffix = predictTypeDefnAdtSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_typeParams == n && parseTypeParamsH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_typeDefnEnumSuffix == n && parseTypeDefnEnumSuffixH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_typeDefnAliasSuffix == n && parseTypeDefnAliasSuffixH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_typeDefnAdtSuffix == n && parseTypeDefnAdtSuffixH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_typeDefnEnumSuffix = predictTypeDefnEnumSuffix(ctx.j)
          val n_typeDefnAliasSuffix = predictTypeDefnAliasSuffix(ctx.j)
          val n_typeDefnAdtSuffix = predictTypeDefnAdtSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_typeDefnEnumSuffix == n && parseTypeDefnEnumSuffixH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_typeDefnAliasSuffix == n && parseTypeDefnAliasSuffixH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_typeDefnAdtSuffix == n && parseTypeDefnAdtSuffixH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTypeDefnEnumSuffix(i: Z): Result = {
    val ctx = Context.create("typeDefnEnumSuffix", u32"0xFE5EEC1B", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_enumMembers = predictEnumMembers(ctx.j)
          if (n_enumMembers >= 0 && parseEnumMembersH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTypeDefnAliasSuffix(i: Z): Result = {
    val ctx = Context.create("typeDefnAliasSuffix", u32"0x1955C4F8", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF20A2856" /* ASSIGN */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTypeDefnAdtSuffix(i: Z): Result = {
    val ctx = Context.create("typeDefnAdtSuffix", u32"0x1BBC16DC", ISZ(state"1", state"2", state"3", state"4", state"5", state"6", state"7"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_params = predictParams(ctx.j)
          val n_supers = predictSupers(ctx.j)
          val n_annot = predictAnnot(ctx.j)
          val n_typeDefnAdtMembers = predictTypeDefnAdtMembers(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_params == n && parseParamsH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_supers == n && parseSupersH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_annot == n && parseAnnotH(ctx, state"7")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_typeDefnAdtMembers == n && parseTypeDefnAdtMembersH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_supers = predictSupers(ctx.j)
          val n_annot = predictAnnot(ctx.j)
          val n_typeDefnAdtMembers = predictTypeDefnAdtMembers(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_supers == n && parseSupersH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_typeDefnAdtMembers == n && parseTypeDefnAdtMembersH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_typeDefnAdtMembers = predictTypeDefnAdtMembers(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_typeDefnAdtMembers == n && parseTypeDefnAdtMembersH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_typeDefnAdtMembers = predictTypeDefnAdtMembers(ctx.j)
          if (n_typeDefnAdtMembers >= 0 && parseTypeDefnAdtMembersH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case state"5" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_typeDefnAdtMembers = predictTypeDefnAdtMembers(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_typeDefnAdtMembers == n && parseTypeDefnAdtMembersH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"6" =>
          ctx.found = F
          val n_typeDefnAdtMembers = predictTypeDefnAdtMembers(ctx.j)
          if (n_typeDefnAdtMembers >= 0 && parseTypeDefnAdtMembersH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"7" =>
          ctx.found = F
          val n_typeDefnAdtMembers = predictTypeDefnAdtMembers(ctx.j)
          if (n_typeDefnAdtMembers >= 0 && parseTypeDefnAdtMembersH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTypeDefnAdtMembers(i: Z): Result = {
    val ctx = Context.create("typeDefnAdtMembers", u32"0xD5E5A5A2", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_member = predictMember(ctx.j)
          if (n_member >= 0 && parseMemberH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"2")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTypeParams(i: Z): Result = {
    val ctx = Context.create("typeParams", u32"0x2638F04D", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x951E9CFB" /* LSQUARE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_typeParam = predictTypeParam(ctx.j)
          if (n_typeParam >= 0 && parseTypeParamH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_typeParamSuffix = predictTypeParamSuffix(ctx.j)
          if (n_typeParamSuffix >= 0 && parseTypeParamSuffixH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xA97171F1" /* RSQUARE */ => ctx.updateTerminal(token, state"3")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTypeParamSuffix(i: Z): Result = {
    val ctx = Context.create("typeParamSuffix", u32"0x568502F3", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_typeParam = predictTypeParam(ctx.j)
          if (n_typeParam >= 0 && parseTypeParamH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTypeParam(i: Z): Result = {
    val ctx = Context.create("typeParam", u32"0x698E1A88", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_mod = predictMod(ctx.j)
          if (n_mod >= 0 && parseModH(ctx, state"0")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseEnumMembers(i: Z): Result = {
    val ctx = Context.create("enumMembers", u32"0xB2C695F2", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaId = predictCommaId(ctx.j)
          if (n_commaId >= 0 && parseCommaIdH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"3")
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaId(i: Z): Result = {
    val ctx = Context.create("commaId", u32"0x830C448A", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseParams(i: Z): Result = {
    val ctx = Context.create("params", u32"0x781C82F4", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x643EF7CD" /* LPAREN */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_param = predictParam(ctx.j)
          if (n_param >= 0 && parseParamH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaParams = predictCommaParams(ctx.j)
          if (n_commaParams >= 0 && parseCommaParamsH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"3")
              case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaParams(i: Z): Result = {
    val ctx = Context.create("commaParams", u32"0x99EB5414", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_param = predictParam(ctx.j)
          if (n_param >= 0 && parseParamH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseParam(i: Z): Result = {
    val ctx = Context.create("param", u32"0x35B1E2B1", ISZ(state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_mod = predictMod(ctx.j)
          if (n_mod >= 0 && parseModH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x18F352F5" /* VAR */ => ctx.updateTerminal(token, state"1")
              case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_mod = predictMod(ctx.j)
          if (n_mod >= 0 && parseModH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"5")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x203A34BF" /* ARROW */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"5")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseSupers(i: Z): Result = {
    val ctx = Context.create("supers", u32"0x65290CBC", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_supr = predictSupr(ctx.j)
          if (n_supr >= 0 && parseSuprH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaSuper = predictCommaSuper(ctx.j)
          if (n_commaSuper >= 0 && parseCommaSuperH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaSuper(i: Z): Result = {
    val ctx = Context.create("commaSuper", u32"0x7A5BA01F", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_supr = predictSupr(ctx.j)
          if (n_supr >= 0 && parseSuprH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseSupr(i: Z): Result = {
    val ctx = Context.create("supr", u32"0x71494F9F", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_name = predictName(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_name == n && parseNameH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_name = predictName(ctx.j)
          if (n_name >= 0 && parseNameH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_typeArgs = predictTypeArgs(ctx.j)
          if (n_typeArgs >= 0 && parseTypeArgsH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseAnnot(i: Z): Result = {
    val ctx = Context.create("annot", u32"0x6937F43D", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xD735687B" /* AT */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x951E9CFB" /* LSQUARE */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annotArg = predictAnnotArg(ctx.j)
          if (n_annotArg >= 0 && parseAnnotArgH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xA97171F1" /* RSQUARE */ => ctx.updateTerminal(token, state"3")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseAnnotArg(i: Z): Result = {
    val ctx = Context.create("annotArg", u32"0x0566A2B0", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case u32"0xA7CF0FE0" /* STRING */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          val n_annotArgNested = predictAnnotArgNested(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_exp == n && parseExpH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_annotArgNested == n && parseAnnotArgNestedH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaExp = predictCommaExp(ctx.j)
          if (n_commaExp >= 0 && parseCommaExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseAnnotArgNested(i: Z): Result = {
    val ctx = Context.create("annotArgNested", u32"0xF5187864", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x951E9CFB" /* LSQUARE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annotArg = predictAnnotArg(ctx.j)
          if (n_annotArg >= 0 && parseAnnotArgH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annotArg = predictAnnotArg(ctx.j)
          if (n_annotArg >= 0 && parseAnnotArgH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xA97171F1" /* RSQUARE */ => ctx.updateTerminal(token, state"3")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseVarDefn(i: Z): Result = {
    val ctx = Context.create("varDefn", u32"0xB785E355", ISZ(state"2", state"3", state"4", state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x18F352F5" /* VAR */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_mod = predictMod(ctx.j)
          if (n_mod >= 0 && parseModH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_colonType = predictColonType(ctx.j)
          val n_annot = predictAnnot(ctx.j)
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_colonType == n && parseColonTypeH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_annot == n && parseAnnotH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assignSuffix == n && parseAssignSuffixH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assignSuffix == n && parseAssignSuffixH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          if (n_assignSuffix >= 0 && parseAssignSuffixH(ctx, state"5")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseAssignSuffix(i: Z): Result = {
    val ctx = Context.create("assignSuffix", u32"0x1C4C8745", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF20A2856" /* ASSIGN */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_rhs = predictRhs(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_rhs == n && parseRhsH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_rhs = predictRhs(ctx.j)
          if (n_rhs >= 0 && parseRhsH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseDefDefn(i: Z): Result = {
    val ctx = Context.create("defDefn", u32"0x3CD319B2", ISZ(state"2", state"3", state"4", state"5", state"6"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xCE1D1E69" /* DEF */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_mod = predictMod(ctx.j)
          val n_defId = predictDefId(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_mod == n && parseModH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defId == n && parseDefIdH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_typeParams = predictTypeParams(ctx.j)
          val n_defParams = predictDefParams(ctx.j)
          val n_defnTypeSuffix = predictDefnTypeSuffix(ctx.j)
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_typeParams == n && parseTypeParamsH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defParams == n && parseDefParamsH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defnTypeSuffix == n && parseDefnTypeSuffixH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assignSuffix == n && parseAssignSuffixH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_defParams = predictDefParams(ctx.j)
          val n_defnTypeSuffix = predictDefnTypeSuffix(ctx.j)
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_defParams == n && parseDefParamsH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defnTypeSuffix == n && parseDefnTypeSuffixH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assignSuffix == n && parseAssignSuffixH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_defnTypeSuffix = predictDefnTypeSuffix(ctx.j)
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_defnTypeSuffix == n && parseDefnTypeSuffixH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assignSuffix == n && parseAssignSuffixH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" =>
          ctx.found = F
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          if (n_assignSuffix >= 0 && parseAssignSuffixH(ctx, state"6")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"6" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseDefnTypeSuffix(i: Z): Result = {
    val ctx = Context.create("defnTypeSuffix", u32"0xEA1E4B25", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          if (n_annot >= 0 && parseAnnotH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseDefId(i: Z): Result = {
    val ctx = Context.create("defId", u32"0xCD1D03AC", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case u32"0x3D594292" /* OP */ => ctx.updateTerminal(token, state"1")
            case u32"0xFA31AB98" /* SYMBOL */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseDefParams(i: Z): Result = {
    val ctx = Context.create("defParams", u32"0x8F462218", ISZ(state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x643EF7CD" /* LPAREN */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_defParam = predictDefParam(ctx.j)
          if (n_defParam >= 0 && parseDefParamH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_defParamSuffix = predictDefParamSuffix(ctx.j)
          if (n_defParamSuffix >= 0 && parseDefParamSuffixH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"4")
              case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"5")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"4")
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"5")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"5")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseDefParam(i: Z): Result = {
    val ctx = Context.create("defParam", u32"0xC60FF6EE", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_mod = predictMod(ctx.j)
          if (n_mod >= 0 && parseModH(ctx, state"0")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseDefParamSuffix(i: Z): Result = {
    val ctx = Context.create("defParamSuffix", u32"0xD51299CB", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_defParamSuffixVarargs = predictDefParamSuffixVarargs(ctx.j)
          val n_defParam = predictDefParam(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_defParamSuffixVarargs == n && parseDefParamSuffixVarargsH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defParam == n && parseDefParamH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case state"3" =>
          ctx.found = F
          val n_defParamSuffix = predictDefParamSuffix(ctx.j)
          if (n_defParamSuffix >= 0 && parseDefParamSuffixH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseDefParamSuffixVarargs(i: Z): Result = {
    val ctx = Context.create("defParamSuffixVarargs", u32"0x7AADB0A9", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xAB02A212" /* TO */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_defParam = predictDefParam(ctx.j)
          if (n_defParam >= 0 && parseDefParamH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseStmt(i: Z): Result = {
    val ctx = Context.create("stmt", u32"0x24B372D3", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_expOrAssignStmt = predictExpOrAssignStmt(ctx.j)
          val n_varPattern = predictVarPattern(ctx.j)
          val n_ifStmt = predictIfStmt(ctx.j)
          val n_whileStmt = predictWhileStmt(ctx.j)
          val n_forStmt = predictForStmt(ctx.j)
          val n_deduceStmt = predictDeduceStmt(ctx.j)
          val n_matchStmt = predictMatchStmt(ctx.j)
          val n_defStmt = predictDefStmt(ctx.j)
          val n_assertumeStmt = predictAssertumeStmt(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_expOrAssignStmt == n && parseExpOrAssignStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_varPattern == n && parseVarPatternH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_ifStmt == n && parseIfStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_whileStmt == n && parseWhileStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_forStmt == n && parseForStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_deduceStmt == n && parseDeduceStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_matchStmt == n && parseMatchStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defStmt == n && parseDefStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assertumeStmt == n && parseAssertumeStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseAssertumeStmt(i: Z): Result = {
    val ctx = Context.create("assertumeStmt", u32"0x7499B4CD", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF5079A9D" /* ASSERT */ => ctx.updateTerminal(token, state"1")
            case u32"0x02C3896F" /* ASSUME */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaExp = predictCommaExp(ctx.j)
          if (n_commaExp >= 0 && parseCommaExpH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseDefStmt(i: Z): Result = {
    val ctx = Context.create("defStmt", u32"0x8EDAF169", ISZ(state"2", state"3", state"4", state"5", state"6"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xCE1D1E69" /* DEF */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_mod = predictMod(ctx.j)
          val n_defId = predictDefId(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_mod == n && parseModH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defId == n && parseDefIdH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_typeParams = predictTypeParams(ctx.j)
          val n_defParams = predictDefParams(ctx.j)
          val n_defnTypeSuffix = predictDefnTypeSuffix(ctx.j)
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_typeParams == n && parseTypeParamsH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defParams == n && parseDefParamsH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defnTypeSuffix == n && parseDefnTypeSuffixH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assignSuffix == n && parseAssignSuffixH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_defParams = predictDefParams(ctx.j)
          val n_defnTypeSuffix = predictDefnTypeSuffix(ctx.j)
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_defParams == n && parseDefParamsH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defnTypeSuffix == n && parseDefnTypeSuffixH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assignSuffix == n && parseAssignSuffixH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_defnTypeSuffix = predictDefnTypeSuffix(ctx.j)
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_defnTypeSuffix == n && parseDefnTypeSuffixH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assignSuffix == n && parseAssignSuffixH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" =>
          ctx.found = F
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          if (n_assignSuffix >= 0 && parseAssignSuffixH(ctx, state"6")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"6" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseExpOrAssignStmt(i: Z): Result = {
    val ctx = Context.create("expOrAssignStmt", u32"0x4CD7042C", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_idStmt = predictIdStmt(ctx.j)
          val n_expStmt = predictExpStmt(ctx.j)
          val n_doStmt = predictDoStmt(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_idStmt == n && parseIdStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_expStmt == n && parseExpStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_doStmt == n && parseDoStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseIdStmt(i: Z): Result = {
    val ctx = Context.create("idStmt", u32"0xB8C111E8", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_idStmtSuffix = predictIdStmtSuffix(ctx.j)
          if (n_idStmtSuffix >= 0 && parseIdStmtSuffixH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseIdStmtSuffix(i: Z): Result = {
    val ctx = Context.create("idStmtSuffix", u32"0x82D2F277", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          val n_labelSuffix = predictLabelSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assignSuffix == n && parseAssignSuffixH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_labelSuffix == n && parseLabelSuffixH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseLabelSuffix(i: Z): Result = {
    val ctx = Context.create("labelSuffix", u32"0x983111BB", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          if (n_annot >= 0 && parseAnnotH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseExpStmt(i: Z): Result = {
    val ctx = Context.create("expStmt", u32"0xD676DC40", ISZ(state"2", state"3", state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp0 = predictExp0(ctx.j)
          if (n_exp0 >= 0 && parseExp0H(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_access = predictAccess(ctx.j)
          if (n_access >= 0 && parseAccessH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_access = predictAccess(ctx.j)
          val n_annot = predictAnnot(ctx.j)
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_access == n && parseAccessH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assignSuffix == n && parseAssignSuffixH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_assignSuffix = predictAssignSuffix(ctx.j)
          if (n_assignSuffix >= 0 && parseAssignSuffixH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseDoStmt(i: Z): Result = {
    val ctx = Context.create("doStmt", u32"0xBC8FD161", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x1E045002" /* DO */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_exp = predictExp(ctx.j)
          val n_mod = predictMod(ctx.j)
          val n_block = predictBlock(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_exp == n && parseExpH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_mod == n && parseModH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_block == n && parseBlockH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          val n_mod = predictMod(ctx.j)
          val n_block = predictBlock(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_exp == n && parseExpH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_mod == n && parseModH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_block == n && parseBlockH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case state"4" =>
          ctx.found = F
          val n_mod = predictMod(ctx.j)
          val n_block = predictBlock(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_mod == n && parseModH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_block == n && parseBlockH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseVarPattern(i: Z): Result = {
    val ctx = Context.create("varPattern", u32"0x4A56733D", ISZ(state"6"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x18F352F5" /* VAR */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_pattern0 = predictPattern0(ctx.j)
          if (n_pattern0 >= 0 && parsePattern0H(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_colonType1 = predictColonType1(ctx.j)
          if (n_colonType1 >= 0 && parseColonType1H(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xF20A2856" /* ASSIGN */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF20A2856" /* ASSIGN */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_rhs = predictRhs(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_rhs == n && parseRhsH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" =>
          ctx.found = F
          val n_rhs = predictRhs(ctx.j)
          if (n_rhs >= 0 && parseRhsH(ctx, state"6")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"6" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseRhs(i: Z): Result = {
    val ctx = Context.create("rhs", u32"0xF0297F27", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          val n_block = predictBlock(ctx.j)
          val n_ifStmt = predictIfStmt(ctx.j)
          val n_matchStmt = predictMatchStmt(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_exp == n && parseExpH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_block == n && parseBlockH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_ifStmt == n && parseIfStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_matchStmt == n && parseMatchStmtH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseIfStmt(i: Z): Result = {
    val ctx = Context.create("ifStmt", u32"0x72C6B874", ISZ(state"4", state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x8210408E" /* IF */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_block = predictBlock(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_block == n && parseBlockH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_block = predictBlock(ctx.j)
          if (n_block >= 0 && parseBlockH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_els = predictEls(ctx.j)
          if (n_els >= 0 && parseElsH(ctx, state"5")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseBlock(i: Z): Result = {
    val ctx = Context.create("block", u32"0xAA25218B", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_blockContent = predictBlockContent(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_blockContent == n && parseBlockContentH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_blockContent = predictBlockContent(ctx.j)
          if (n_blockContent >= 0 && parseBlockContentH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseBlockContent(i: Z): Result = {
    val ctx = Context.create("blockContent", u32"0x41D34A85", ISZ(state"0", state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_stmt = predictStmt(ctx.j)
          val n_ret = predictRet(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_stmt == n && parseStmtH(ctx, state"0")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_ret == n && parseRetH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            ctx.updateAcceptingEpsilon(state"0")
            return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseRet(i: Z): Result = {
    val ctx = Context.create("ret", u32"0x618263BA", ISZ(state"1", state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xD3E917DC" /* RETURN */ => ctx.updateTerminal(token, state"1")
            case u32"0x37F385AB" /* HALT */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_rhs = predictRhs(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_rhs == n && parseRhsH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_rhs = predictRhs(ctx.j)
          if (n_rhs >= 0 && parseRhsH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseEls(i: Z): Result = {
    val ctx = Context.create("els", u32"0x83C72679", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x04DDB5EF" /* ELSE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_elsIf = predictElsIf(ctx.j)
          val n_block = predictBlock(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_elsIf == n && parseElsIfH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_block == n && parseBlockH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseElsIf(i: Z): Result = {
    val ctx = Context.create("elsIf", u32"0x334E59A9", ISZ(state"4", state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x8210408E" /* IF */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_block = predictBlock(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_block == n && parseBlockH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_block = predictBlock(ctx.j)
          if (n_block >= 0 && parseBlockH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_els = predictEls(ctx.j)
          if (n_els >= 0 && parseElsH(ctx, state"5")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseWhileStmt(i: Z): Result = {
    val ctx = Context.create("whileStmt", u32"0x5D05CC86", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0E0F65B7" /* WHILE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_block = predictBlock(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_block == n && parseBlockH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_block = predictBlock(ctx.j)
          if (n_block >= 0 && parseBlockH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseForStmt(i: Z): Result = {
    val ctx = Context.create("forStmt", u32"0xF5A239EA", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xBF5AD766" /* FOR */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_forRange = predictForRange(ctx.j)
          if (n_forRange >= 0 && parseForRangeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaForRange = predictCommaForRange(ctx.j)
          val n_block = predictBlock(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_commaForRange == n && parseCommaForRangeH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_block == n && parseBlockH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseForRange(i: Z): Result = {
    val ctx = Context.create("forRange", u32"0xF6BB1EA0", ISZ(state"3", state"4", state"5", state"6"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case u32"0xF0D3D2C8" /* UNDERSCORE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_rangeSuffix = predictRangeSuffix(ctx.j)
          val n_ifExp = predictIfExp(ctx.j)
          val n_annot = predictAnnot(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_rangeSuffix == n && parseRangeSuffixH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_ifExp == n && parseIfExpH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_annot == n && parseAnnotH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_ifExp = predictIfExp(ctx.j)
          val n_annot = predictAnnot(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_ifExp == n && parseIfExpH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_annot == n && parseAnnotH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          if (n_annot >= 0 && parseAnnotH(ctx, state"6")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"6" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaForRange(i: Z): Result = {
    val ctx = Context.create("commaForRange", u32"0x4A80BD07", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_forRange = predictForRange(ctx.j)
          if (n_forRange >= 0 && parseForRangeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseRangeSuffix(i: Z): Result = {
    val ctx = Context.create("rangeSuffix", u32"0x53B50CBD", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xAB02A212" /* TO */ => ctx.updateTerminal(token, state"1")
            case u32"0x4F158144" /* UNTIL */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_byExp = predictByExp(ctx.j)
          if (n_byExp >= 0 && parseByExpH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseByExp(i: Z): Result = {
    val ctx = Context.create("byExp", u32"0x987D502D", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA7E1A028" /* BY */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaExp(i: Z): Result = {
    val ctx = Context.create("commaExp", u32"0x2393742F", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseMatchStmt(i: Z): Result = {
    val ctx = Context.create("matchStmt", u32"0xB29ABF0D", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x142AC92F" /* MATCH */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_matchCases = predictMatchCases(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_matchCases == n && parseMatchCasesH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_matchCases = predictMatchCases(ctx.j)
          if (n_matchCases >= 0 && parseMatchCasesH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseMatchCases(i: Z): Result = {
    val ctx = Context.create("matchCases", u32"0x932AE827", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_cas = predictCas(ctx.j)
          if (n_cas >= 0 && parseCasH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_cas = predictCas(ctx.j)
          if (n_cas >= 0 && parseCasH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"3")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parsePattern(i: Z): Result = {
    val ctx = Context.create("pattern", u32"0x23DEC431", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_idTypePattern = predictIdTypePattern(ctx.j)
          val n_pattern0 = predictPattern0(ctx.j)
          val n_wildCardPattern = predictWildCardPattern(ctx.j)
          val n_wildCardSeqPattern = predictWildCardSeqPattern(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_idTypePattern == n && parseIdTypePatternH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_pattern0 == n && parsePattern0H(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_wildCardPattern == n && parseWildCardPatternH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_wildCardSeqPattern == n && parseWildCardSeqPatternH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_idTypePattern = predictIdTypePattern(ctx.j)
          val n_pattern0 = predictPattern0(ctx.j)
          val n_wildCardPattern = predictWildCardPattern(ctx.j)
          val n_wildCardSeqPattern = predictWildCardSeqPattern(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_idTypePattern == n && parseIdTypePatternH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_pattern0 == n && parsePattern0H(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_wildCardPattern == n && parseWildCardPatternH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_wildCardSeqPattern == n && parseWildCardSeqPatternH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parsePattern0(i: Z): Result = {
    val ctx = Context.create("pattern0", u32"0xFF4270E2", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_lit = predictLit(ctx.j)
          val n_refPattern = predictRefPattern(ctx.j)
          val n_patterns = predictPatterns(ctx.j)
          val n_name = predictName(ctx.j)
          val n_idNamePattern = predictIdNamePattern(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_lit == n && parseLitH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_refPattern == n && parseRefPatternH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_patterns == n && parsePatternsH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_name == n && parseNameH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_idNamePattern == n && parseIdNamePatternH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case state"2" =>
          ctx.found = F
          val n_patterns = predictPatterns(ctx.j)
          if (n_patterns >= 0 && parsePatternsH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseRefPattern(i: Z): Result = {
    val ctx = Context.create("refPattern", u32"0xD0388A02", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x9A468353" /* DOT */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_name = predictName(ctx.j)
          if (n_name >= 0 && parseNameH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseIdTypePattern(i: Z): Result = {
    val ctx = Context.create("idTypePattern", u32"0x51AD0D88", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_colonType1 = predictColonType1(ctx.j)
          if (n_colonType1 >= 0 && parseColonType1H(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseColonType1(i: Z): Result = {
    val ctx = Context.create("colonType1", u32"0x4F6B0B02", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_type1 = predictType1(ctx.j)
          if (n_type1 >= 0 && parseType1H(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseIdNamePattern(i: Z): Result = {
    val ctx = Context.create("idNamePattern", u32"0x6AB5150F", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0xD735687B" /* AT */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_name = predictName(ctx.j)
          if (n_name >= 0 && parseNameH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_patterns = predictPatterns(ctx.j)
          if (n_patterns >= 0 && parsePatternsH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseWildCardPattern(i: Z): Result = {
    val ctx = Context.create("wildCardPattern", u32"0xDC465F5F", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF0D3D2C8" /* UNDERSCORE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_colonType1 = predictColonType1(ctx.j)
          if (n_colonType1 >= 0 && parseColonType1H(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseWildCardSeqPattern(i: Z): Result = {
    val ctx = Context.create("wildCardSeqPattern", u32"0xD71972DE", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x7EF5EC39" /* STAR */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parsePatterns(i: Z): Result = {
    val ctx = Context.create("patterns", u32"0xE923061E", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x643EF7CD" /* LPAREN */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_patternsArg = predictPatternsArg(ctx.j)
          if (n_patternsArg >= 0 && parsePatternsArgH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"3")
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parsePatternsArg(i: Z): Result = {
    val ctx = Context.create("patternsArg", u32"0x1DC061F8", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_pattern = predictPattern(ctx.j)
          val n_namedPattern = predictNamedPattern(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_pattern == n && parsePatternH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_namedPattern == n && parseNamedPatternH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_commaPattern = predictCommaPattern(ctx.j)
          if (n_commaPattern >= 0 && parseCommaPatternH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaNamedPattern = predictCommaNamedPattern(ctx.j)
          if (n_commaNamedPattern >= 0 && parseCommaNamedPatternH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseNamedPattern(i: Z): Result = {
    val ctx = Context.create("namedPattern", u32"0x51B5ECF0", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF20A2856" /* ASSIGN */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_pattern = predictPattern(ctx.j)
          if (n_pattern >= 0 && parsePatternH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaPattern(i: Z): Result = {
    val ctx = Context.create("commaPattern", u32"0x464D1AE1", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_pattern = predictPattern(ctx.j)
          if (n_pattern >= 0 && parsePatternH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaNamedPattern(i: Z): Result = {
    val ctx = Context.create("commaNamedPattern", u32"0x576742FA", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF20A2856" /* ASSIGN */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_pattern = predictPattern(ctx.j)
          if (n_pattern >= 0 && parsePatternH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseExp(i: Z): Result = {
    val ctx = Context.create("exp", u32"0xC2D3BB33", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp3 = predictExp3(ctx.j)
          val n_forExp = predictForExp(ctx.j)
          val n_defAnon = predictDefAnon(ctx.j)
          val n_quant = predictQuant(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_exp3 == n && parseExp3H(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_forExp == n && parseForExpH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defAnon == n && parseDefAnonH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_quant == n && parseQuantH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseExp3(i: Z): Result = {
    val ctx = Context.create("exp3", u32"0x7690967A", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp2 = predictExp2(ctx.j)
          if (n_exp2 >= 0 && parseExp2H(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_infixSuffix = predictInfixSuffix(ctx.j)
          if (n_infixSuffix >= 0 && parseInfixSuffixH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseInfixSuffix(i: Z): Result = {
    val ctx = Context.create("infixSuffix", u32"0x3C3E78A2", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_infixOp = predictInfixOp(ctx.j)
          if (n_infixOp >= 0 && parseInfixOpH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp2 = predictExp2(ctx.j)
          if (n_exp2 >= 0 && parseExp2H(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseInfixOp(i: Z): Result = {
    val ctx = Context.create("infixOp", u32"0xF1501FF2", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x3D594292" /* OP */ => ctx.updateTerminal(token, state"1")
            case u32"0xFA31AB98" /* SYMBOL */ => ctx.updateTerminal(token, state"1")
            case u32"0x5ADD78B7" /* LANGLE */ => ctx.updateTerminal(token, state"1")
            case u32"0x01420030" /* RANGLE */ => ctx.updateTerminal(token, state"1")
            case u32"0x15503F3A" /* LRANGLE */ => ctx.updateTerminal(token, state"1")
            case u32"0x7EF5EC39" /* STAR */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseExp2(i: Z): Result = {
    val ctx = Context.create("exp2", u32"0x49E21648", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp1 = predictExp1(ctx.j)
          if (n_exp1 >= 0 && parseExp1H(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_access = predictAccess(ctx.j)
          val n_eta = predictEta(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_access == n && parseAccessH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_eta == n && parseEtaH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseEta(i: Z): Result = {
    val ctx = Context.create("eta", u32"0x08E04CF9", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF0D3D2C8" /* UNDERSCORE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseExp1(i: Z): Result = {
    val ctx = Context.create("exp1", u32"0x6ADDFAF7", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp0 = predictExp0(ctx.j)
          val n_paren = predictParen(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_exp0 == n && parseExp0H(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_paren == n && parseParenH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x3D594292" /* OP */ => ctx.updateTerminal(token, state"1")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp0 = predictExp0(ctx.j)
          val n_paren = predictParen(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_exp0 == n && parseExp0H(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_paren == n && parseParenH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseExp0(i: Z): Result = {
    val ctx = Context.create("exp0", u32"0xC0DFDD8F", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_idExp = predictIdExp(ctx.j)
          val n_thisExp = predictThisExp(ctx.j)
          val n_superExp = predictSuperExp(ctx.j)
          val n_lit = predictLit(ctx.j)
          val n_interp = predictInterp(ctx.j)
          val n_pureBlock = predictPureBlock(ctx.j)
          val n_jsonLit = predictJsonLit(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_idExp == n && parseIdExpH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_thisExp == n && parseThisExpH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_superExp == n && parseSuperExpH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_lit == n && parseLitH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_interp == n && parseInterpH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_pureBlock == n && parsePureBlockH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_jsonLit == n && parseJsonLitH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parsePureBlock(i: Z): Result = {
    val ctx = Context.create("pureBlock", u32"0x2BB3F8B4", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xD735687B" /* AT */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_stmt = predictStmt(ctx.j)
          if (n_stmt >= 0 && parseStmtH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_stmt = predictStmt(ctx.j)
          if (n_stmt >= 0 && parseStmtH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseIdExp(i: Z): Result = {
    val ctx = Context.create("idExp", u32"0xFAE4B488", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_typeArgs = predictTypeArgs(ctx.j)
          if (n_typeArgs >= 0 && parseTypeArgsH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseThisExp(i: Z): Result = {
    val ctx = Context.create("thisExp", u32"0xD728CFA1", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x93DEEB98" /* THIS */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseSuperExp(i: Z): Result = {
    val ctx = Context.create("superExp", u32"0x51E4C72C", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x136381C3" /* SUPER */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseAccess(i: Z): Result = {
    val ctx = Context.create("access", u32"0x1037F1F6", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_fieldAccess = predictFieldAccess(ctx.j)
          val n_applyAccess = predictApplyAccess(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_fieldAccess == n && parseFieldAccessH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_applyAccess == n && parseApplyAccessH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xA4512A72" /* QUESTION */ => ctx.updateTerminal(token, state"1")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_fieldAccess = predictFieldAccess(ctx.j)
          val n_applyAccess = predictApplyAccess(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_fieldAccess == n && parseFieldAccessH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_applyAccess == n && parseApplyAccessH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseFieldAccess(i: Z): Result = {
    val ctx = Context.create("fieldAccess", u32"0x0C4BEC0F", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x9A468353" /* DOT */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_typeArgs = predictTypeArgs(ctx.j)
          if (n_typeArgs >= 0 && parseTypeArgsH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseApplyAccess(i: Z): Result = {
    val ctx = Context.create("applyAccess", u32"0xA72827F7", ISZ(state"4", state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x643EF7CD" /* LPAREN */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_args = predictArgs(ctx.j)
          if (n_args >= 0 && parseArgsH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"3")
              case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"3")
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_fn = predictFn(ctx.j)
          if (n_fn >= 0 && parseFnH(ctx, state"5")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseFn(i: Z): Result = {
    val ctx = Context.create("fn", u32"0xA0B7F904", ISZ(state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_fnBody = predictFnBody(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_fnBody == n && parseFnBodyH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_fnBody = predictFnBody(ctx.j)
          if (n_fnBody >= 0 && parseFnBodyH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          token.tipe match {
            case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"5")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseFnBody(i: Z): Result = {
    val ctx = Context.create("fnBody", u32"0xE8837734", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_blockContent = predictBlockContent(ctx.j)
          val n_cas = predictCas(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_blockContent == n && parseBlockContentH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_cas == n && parseCasH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case state"2" =>
          ctx.found = F
          val n_cas = predictCas(ctx.j)
          if (n_cas >= 0 && parseCasH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseLit(i: Z): Result = {
    val ctx = Context.create("lit", u32"0x120C7129", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xEE99A672" /* TRUE */ => ctx.updateTerminal(token, state"1")
            case u32"0x43340E3B" /* FALSE */ => ctx.updateTerminal(token, state"1")
            case u32"0x589C233C" /* INT */ => ctx.updateTerminal(token, state"1")
            case u32"0x5028A536" /* HEX */ => ctx.updateTerminal(token, state"1")
            case u32"0x4E33B13F" /* BIN */ => ctx.updateTerminal(token, state"1")
            case u32"0x1F9A2C24" /* REAL */ => ctx.updateTerminal(token, state"1")
            case u32"0xA7CF0FE0" /* STRING */ => ctx.updateTerminal(token, state"1")
            case u32"0x84A54E6B" /* MSTR */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJsonLit(i: Z): Result = {
    val ctx = Context.create("jsonLit", u32"0xD2D8A853", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x26334490" /* BACKTICK */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_jsonObject = predictJsonObject(ctx.j)
          val n_jsonArray = predictJsonArray(ctx.j)
          val n_jsonParen = predictJsonParen(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_jsonObject == n && parseJsonObjectH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_jsonArray == n && parseJsonArrayH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_jsonParen == n && parseJsonParenH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJsonParen(i: Z): Result = {
    val ctx = Context.create("jsonParen", u32"0x02ABB62F", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x643EF7CD" /* LPAREN */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_jsonExp = predictJsonExp(ctx.j)
          if (n_jsonExp >= 0 && parseJsonExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJson(i: Z): Result = {
    val ctx = Context.create("json", u32"0x68E8F0CA", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_jsonObject = predictJsonObject(ctx.j)
          val n_jsonArray = predictJsonArray(ctx.j)
          val n_jsonExp = predictJsonExp(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_jsonObject == n && parseJsonObjectH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_jsonArray == n && parseJsonArrayH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_jsonExp == n && parseJsonExpH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJsonObject(i: Z): Result = {
    val ctx = Context.create("jsonObject", u32"0x602986A3", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_jsonKeyValue = predictJsonKeyValue(ctx.j)
          if (n_jsonKeyValue >= 0 && parseJsonKeyValueH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaJsonKeyValue = predictCommaJsonKeyValue(ctx.j)
          if (n_commaJsonKeyValue >= 0 && parseCommaJsonKeyValueH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"3")
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJsonKeyValue(i: Z): Result = {
    val ctx = Context.create("jsonKeyValue", u32"0x5D508F79", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_jsonKey = predictJsonKey(ctx.j)
          if (n_jsonKey >= 0 && parseJsonKeyH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_json = predictJson(ctx.j)
          if (n_json >= 0 && parseJsonH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJsonKey(i: Z): Result = {
    val ctx = Context.create("jsonKey", u32"0x938F5F0E", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case u32"0xA7CF0FE0" /* STRING */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaJsonKeyValue(i: Z): Result = {
    val ctx = Context.create("commaJsonKeyValue", u32"0xCDF9EEB7", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_jsonKeyValue = predictJsonKeyValue(ctx.j)
          if (n_jsonKeyValue >= 0 && parseJsonKeyValueH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJsonArray(i: Z): Result = {
    val ctx = Context.create("jsonArray", u32"0x3DE8E515", ISZ(state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x951E9CFB" /* LSQUARE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_json = predictJson(ctx.j)
          if (n_json >= 0 && parseJsonH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaJson = predictCommaJson(ctx.j)
          if (n_commaJson >= 0 && parseCommaJsonH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"4")
            case u32"0xA97171F1" /* RSQUARE */ => ctx.updateTerminal(token, state"5")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA97171F1" /* RSQUARE */ => ctx.updateTerminal(token, state"5")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaJson(i: Z): Result = {
    val ctx = Context.create("commaJson", u32"0x2C2B5AF4", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_json = predictJson(ctx.j)
          if (n_json >= 0 && parseJsonH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJsonExp(i: Z): Result = {
    val ctx = Context.create("jsonExp", u32"0x9B278986", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          val n_jsonNull = predictJsonNull(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_exp == n && parseExpH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_jsonNull == n && parseJsonNullH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJsonNull(i: Z): Result = {
    val ctx = Context.create("jsonNull", u32"0x4EB9C629", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x6C774BA6" /* NULL */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseParen(i: Z): Result = {
    val ctx = Context.create("paren", u32"0x1920CA8B", ISZ(state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x643EF7CD" /* LPAREN */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_parenArgs = predictParenArgs(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_parenArgs == n && parseParenArgsH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_parenArgs = predictParenArgs(ctx.j)
          if (n_parenArgs >= 0 && parseParenArgsH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"4")
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"5")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"5")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseParenArgs(i: Z): Result = {
    val ctx = Context.create("parenArgs", u32"0x7845A329", ISZ(state"1", state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          val n_namedExpAnnot = predictNamedExpAnnot(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_exp == n && parseExpH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_namedExpAnnot == n && parseNamedExpAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_commaExpAnnot = predictCommaExpAnnot(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_commaExpAnnot == n && parseCommaExpAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaExpAnnot = predictCommaExpAnnot(ctx.j)
          if (n_commaExpAnnot >= 0 && parseCommaExpAnnotH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_commaNamedExpAnnot = predictCommaNamedExpAnnot(ctx.j)
          if (n_commaNamedExpAnnot >= 0 && parseCommaNamedExpAnnotH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseNamedExpAnnot(i: Z): Result = {
    val ctx = Context.create("namedExpAnnot", u32"0x10535E6E", ISZ(state"3", state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF20A2856" /* ASSIGN */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          if (n_annot >= 0 && parseAnnotH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaExpAnnot(i: Z): Result = {
    val ctx = Context.create("commaExpAnnot", u32"0x884BA8BC", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          if (n_annot >= 0 && parseAnnotH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaNamedExpAnnot(i: Z): Result = {
    val ctx = Context.create("commaNamedExpAnnot", u32"0x619A7F97", ISZ(state"4", state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF20A2856" /* ASSIGN */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          if (n_annot >= 0 && parseAnnotH(ctx, state"5")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCas(i: Z): Result = {
    val ctx = Context.create("cas", u32"0xCD3E833F", ISZ(state"6"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x186E11D7" /* CASE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_pattern = predictPattern(ctx.j)
          if (n_pattern >= 0 && parsePatternH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_ifExp = predictIfExp(ctx.j)
          if (n_ifExp >= 0 && parseIfExpH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x203A34BF" /* ARROW */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0x203A34BF" /* ARROW */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_blockContent = predictBlockContent(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_blockContent == n && parseBlockContentH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" =>
          ctx.found = F
          val n_blockContent = predictBlockContent(ctx.j)
          if (n_blockContent >= 0 && parseBlockContentH(ctx, state"6")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"6" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseIfExp(i: Z): Result = {
    val ctx = Context.create("ifExp", u32"0x57FDC848", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x8210408E" /* IF */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseForExp(i: Z): Result = {
    val ctx = Context.create("forExp", u32"0x67C866A4", ISZ(state"6"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x49425B4A" /* YIELD */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_forRange = predictForRange(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_forRange == n && parseForRangeH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_forRange = predictForRange(ctx.j)
          if (n_forRange >= 0 && parseForRangeH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_commaForRange = predictCommaForRange(ctx.j)
          if (n_commaForRange >= 0 && parseCommaForRangeH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x203A34BF" /* ARROW */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_rhs = predictRhs(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_rhs == n && parseRhsH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" =>
          ctx.found = F
          val n_rhs = predictRhs(ctx.j)
          if (n_rhs >= 0 && parseRhsH(ctx, state"6")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"6" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseDefAnon(i: Z): Result = {
    val ctx = Context.create("defAnon", u32"0x22372D74", ISZ(state"6"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xCE1D1E69" /* DEF */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_mod = predictMod(ctx.j)
          val n_defParams = predictDefParams(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_mod == n && parseModH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_defParams == n && parseDefParamsH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_colonType = predictColonType(ctx.j)
          if (n_colonType >= 0 && parseColonTypeH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x9A468353" /* DOT */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0x9A468353" /* DOT */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_rhs = predictRhs(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_rhs == n && parseRhsH(ctx, state"6")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" =>
          ctx.found = F
          val n_rhs = predictRhs(ctx.j)
          if (n_rhs >= 0 && parseRhsH(ctx, state"6")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"6" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseColonType(i: Z): Result = {
    val ctx = Context.create("colonType", u32"0x7E03BF28", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseQuant(i: Z): Result = {
    val ctx = Context.create("quant", u32"0x98B4E485", ISZ(state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x8F29683F" /* ALL */ => ctx.updateTerminal(token, state"1")
            case u32"0xC21A525C" /* SOME */ => ctx.updateTerminal(token, state"1")
            case u32"0xFA31AB98" /* SYMBOL */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_quantRange = predictQuantRange(ctx.j)
          if (n_quantRange >= 0 && parseQuantRangeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_quantRange = predictQuantRange(ctx.j)
          if (n_quantRange >= 0 && parseQuantRangeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x203A34BF" /* ARROW */ => ctx.updateTerminal(token, state"3")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_rhs = predictRhs(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_rhs == n && parseRhsH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_rhs = predictRhs(ctx.j)
          if (n_rhs >= 0 && parseRhsH(ctx, state"5")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseQuantRange(i: Z): Result = {
    val ctx = Context.create("quantRange", u32"0x1598B059", ISZ(state"5", state"6"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_idComma = predictIdComma(ctx.j)
          if (n_idComma >= 0 && parseIdCommaH(ctx, state"0")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          if (n_annot >= 0 && parseAnnotH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"3")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_exp = predictExp(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_exp == n && parseExpH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"5")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" =>
          ctx.found = F
          val n_quantRangeSuffix = predictQuantRangeSuffix(ctx.j)
          if (n_quantRangeSuffix >= 0 && parseQuantRangeSuffixH(ctx, state"6")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"6" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseIdComma(i: Z): Result = {
    val ctx = Context.create("idComma", u32"0x90358A28", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseQuantRangeSuffix(i: Z): Result = {
    val ctx = Context.create("quantRangeSuffix", u32"0xA6562E8A", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xAB02A212" /* TO */ => ctx.updateTerminal(token, state"1")
            case u32"0x4F158144" /* UNTIL */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_exp = predictExp(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_exp == n && parseExpH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseDeduceStmt(i: Z): Result = {
    val ctx = Context.create("deduceStmt", u32"0x79CB0F51", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FBD9BE6" /* DEDUCE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_truthTable = predictTruthTable(ctx.j)
          val n_proof = predictProof(ctx.j)
          val n_sequent = predictSequent(ctx.j)
          val n_expProof = predictExpProof(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_truthTable == n && parseTruthTableH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_proof == n && parseProofH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_sequent == n && parseSequentH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_expProof == n && parseExpProofH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case state"3" =>
          ctx.found = F
          val n_sequent = predictSequent(ctx.j)
          if (n_sequent >= 0 && parseSequentH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseProof(i: Z): Result = {
    val ctx = Context.create("proof", u32"0xD0DAAF2D", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_proofStep = predictProofStep(ctx.j)
          if (n_proofStep >= 0 && parseProofStepH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"2")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseSequent(i: Z): Result = {
    val ctx = Context.create("sequent", u32"0x625521E7", ISZ(state"4", state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exps = predictExps(ctx.j)
          if (n_exps >= 0 && parseExpsH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x611F05DC" /* SEQUENT */ => ctx.updateTerminal(token, state"3")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x611F05DC" /* SEQUENT */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_proof = predictProof(ctx.j)
          if (n_proof >= 0 && parseProofH(ctx, state"5")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseExps(i: Z): Result = {
    val ctx = Context.create("exps", u32"0xBFC098D4", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_commaExp = predictCommaExp(ctx.j)
          if (n_commaExp >= 0 && parseCommaExpH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseExpProof(i: Z): Result = {
    val ctx = Context.create("expProof", u32"0xB02F2234", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x643EF7CD" /* LPAREN */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_expJustOpt = predictExpJustOpt(ctx.j)
          if (n_expJustOpt >= 0 && parseExpJustOptH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaExpJustOpt = predictCommaExpJustOpt(ctx.j)
          if (n_commaExpJustOpt >= 0 && parseCommaExpJustOptH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"3")
              case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaExpJustOpt(i: Z): Result = {
    val ctx = Context.create("commaExpJustOpt", u32"0x65AF1FE5", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_expJustOpt = predictExpJustOpt(ctx.j)
          if (n_expJustOpt >= 0 && parseExpJustOptH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseExpJustOpt(i: Z): Result = {
    val ctx = Context.create("expJustOpt", u32"0x2D0279C1", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_just = predictJust(ctx.j)
          if (n_just >= 0 && parseJustH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseProofStep(i: Z): Result = {
    val ctx = Context.create("proofStep", u32"0xBF1A59A9", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_proofId = predictProofId(ctx.j)
          if (n_proofId >= 0 && parseProofIdH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x9A468353" /* DOT */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          val n_subProof = predictSubProof(ctx.j)
          val n_assumeProofStep = predictAssumeProofStep(ctx.j)
          val n_assertProofStep = predictAssertProofStep(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_exp == n && parseExpH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_subProof == n && parseSubProofH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assumeProofStep == n && parseAssumeProofStepH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_assertProofStep == n && parseAssertProofStepH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_just = predictJust(ctx.j)
          if (n_just >= 0 && parseJustH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseAssumeProofStep(i: Z): Result = {
    val ctx = Context.create("assumeProofStep", u32"0x3EC27540", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x02C3896F" /* ASSUME */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseAssertProofStep(i: Z): Result = {
    val ctx = Context.create("assertProofStep", u32"0xE32BE384", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF5079A9D" /* ASSERT */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_subProof = predictSubProof(ctx.j)
          if (n_subProof >= 0 && parseSubProofH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseSubProof(i: Z): Result = {
    val ctx = Context.create("subProof", u32"0x84258BED", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_freshIds = predictFreshIds(ctx.j)
          val n_proofStep = predictProofStep(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_freshIds == n && parseFreshIdsH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_proofStep == n && parseProofStepH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_proofStep = predictProofStep(ctx.j)
          if (n_proofStep >= 0 && parseProofStepH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"3")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseFreshIds(i: Z): Result = {
    val ctx = Context.create("freshIds", u32"0x34A17B69", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_commaId = predictCommaId(ctx.j)
          val n_colonType = predictColonType(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_commaId == n && parseCommaIdH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_colonType == n && parseColonTypeH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseProofId(i: Z): Result = {
    val ctx = Context.create("proofId", u32"0xC363DAF8", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x589C233C" /* INT */ => ctx.updateTerminal(token, state"1")
            case u32"0xA7CF0FE0" /* STRING */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJust(i: Z): Result = {
    val ctx = Context.create("just", u32"0x856B2739", ISZ(state"2", state"3", state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA7E1A028" /* BY */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_name = predictName(ctx.j)
          if (n_name >= 0 && parseNameH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_justTypeArgs = predictJustTypeArgs(ctx.j)
          val n_justArgs = predictJustArgs(ctx.j)
          val n_proofId = predictProofId(ctx.j)
          val tokenJ1 = tokens.at(ctx.j + 1)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_justTypeArgs == n && parseJustTypeArgsH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_justArgs == n && parseJustArgsH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_proofId == n && tokenJ1.kind == Result.Kind.Normal && tokenJ1.leaf.text != "." && parseProofIdH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_justArgs = predictJustArgs(ctx.j)
          val n_proofId = predictProofId(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_justArgs == n && parseJustArgsH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_proofId == n && parseProofIdH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_proofId = predictProofId(ctx.j)
          val tokenJ1 = tokens.at(ctx.j + 1)
          if (n_proofId >= 0 && tokenJ1.kind == Result.Kind.Normal && tokenJ1.leaf.text != "." && parseProofIdH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJustArgs(i: Z): Result = {
    val ctx = Context.create("justArgs", u32"0x457AC9A1", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x643EF7CD" /* LPAREN */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_args = predictArgs(ctx.j)
          if (n_args >= 0 && parseArgsH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"3")
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseJustTypeArgs(i: Z): Result = {
    val ctx = Context.create("justTypeArgs", u32"0x712E6404", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x951E9CFB" /* LSQUARE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaType = predictCommaType(ctx.j)
          if (n_commaType >= 0 && parseCommaTypeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xA97171F1" /* RSQUARE */ => ctx.updateTerminal(token, state"3")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaType(i: Z): Result = {
    val ctx = Context.create("commaType", u32"0x3180635B", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTruthTable(i: Z): Result = {
    val ctx = Context.create("truthTable", u32"0xC179AFB9", ISZ(state"8", state"9"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x7EF5EC39" /* STAR */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x7EF5EC39" /* STAR */ => ctx.updateTerminal(token, state"1")
            case u32"0x7566CFCC" /* HLINE */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_colonExp = predictColonExp(ctx.j)
          if (n_colonExp >= 0 && parseColonExpH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"3")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_colonExp = predictColonExp(ctx.j)
          if (n_colonExp >= 0 && parseColonExpH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x7566CFCC" /* HLINE */ => ctx.updateTerminal(token, state"5")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"6")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"6" =>
          ctx.found = F
          val n_colonIds = predictColonIds(ctx.j)
          if (n_colonIds >= 0 && parseColonIdsH(ctx, state"7")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"6")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"7" =>
          ctx.found = F
          val n_colonIds = predictColonIds(ctx.j)
          if (n_colonIds >= 0 && parseColonIdsH(ctx, state"7")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0x7566CFCC" /* HLINE */ => ctx.updateTerminal(token, state"8")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"8" =>
          ctx.found = F
          val n_truthTableConclusion = predictTruthTableConclusion(ctx.j)
          if (n_truthTableConclusion >= 0 && parseTruthTableConclusionH(ctx, state"9")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"9" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseColonExp(i: Z): Result = {
    val ctx = Context.create("colonExp", u32"0xA8874083", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseColonIds(i: Z): Result = {
    val ctx = Context.create("colonIds", u32"0xA76DAE7A", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x54FAE327" /* COLON */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTruthTableConclusion(i: Z): Result = {
    val ctx = Context.create("truthTableConclusion", u32"0xC72BB027", ISZ(state"3", state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x951E9CFB" /* LSQUARE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA97171F1" /* RSQUARE */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_truthTableCases = predictTruthTableCases(ctx.j)
          if (n_truthTableCases >= 0 && parseTruthTableCasesH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTruthTableCases(i: Z): Result = {
    val ctx = Context.create("truthTableCases", u32"0xE271CB91", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0xDC2A8959" /* LBRACE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_truthTableCase = predictTruthTableCase(ctx.j)
          if (n_truthTableCase >= 0 && parseTruthTableCaseH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            token.tipe match {
              case u32"0xED041C82" /* RBRACE */ => ctx.updateTerminal(token, state"2")
              case _ =>
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTruthTableCase(i: Z): Result = {
    val ctx = Context.create("truthTableCase", u32"0xF0530019", ISZ(state"3", state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x186E11D7" /* CASE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x203A34BF" /* ARROW */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_truthTableAssignments = predictTruthTableAssignments(ctx.j)
          if (n_truthTableAssignments >= 0 && parseTruthTableAssignmentsH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTruthTableAssignments(i: Z): Result = {
    val ctx = Context.create("truthTableAssignments", u32"0x178F54F3", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_truthTableAssignment = predictTruthTableAssignment(ctx.j)
          if (n_truthTableAssignment >= 0 && parseTruthTableAssignmentH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_commaTruthTableAssignment = predictCommaTruthTableAssignment(ctx.j)
          if (n_commaTruthTableAssignment >= 0 && parseCommaTruthTableAssignmentH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTruthTableAssignment(i: Z): Result = {
    val ctx = Context.create("truthTableAssignment", u32"0xA380A72D", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaTruthTableAssignment(i: Z): Result = {
    val ctx = Context.create("commaTruthTableAssignment", u32"0x49357CCB", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_truthTableAssignment = predictTruthTableAssignment(ctx.j)
          if (n_truthTableAssignment >= 0 && parseTruthTableAssignmentH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseType(i: Z): Result = {
    val ctx = Context.create("type", u32"0xE15F8144", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_type1 = predictType1(ctx.j)
          if (n_type1 >= 0 && parseType1H(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_typeSuffix = predictTypeSuffix(ctx.j)
          if (n_typeSuffix >= 0 && parseTypeSuffixH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTypeSuffix(i: Z): Result = {
    val ctx = Context.create("typeSuffix", u32"0x57CAFABA", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x203A34BF" /* ARROW */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_type1 = predictType1(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_type1 == n && parseType1H(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_type1 = predictType1(ctx.j)
          if (n_type1 >= 0 && parseType1H(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseType1(i: Z): Result = {
    val ctx = Context.create("type1", u32"0x7C9A94B9", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_parenType = predictParenType(ctx.j)
          val n_type0 = predictType0(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_parenType == n && parseParenTypeH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_type0 == n && parseType0H(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case state"2" =>
          ctx.found = F
          val n_type0Suffix = predictType0Suffix(ctx.j)
          if (n_type0Suffix >= 0 && parseType0SuffixH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseParenType(i: Z): Result = {
    val ctx = Context.create("parenType", u32"0xA2D5F02B", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x643EF7CD" /* LPAREN */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_typeParenArgs = predictTypeParenArgs(ctx.j)
          if (n_typeParenArgs >= 0 && parseTypeParenArgsH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"3")
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA5073992" /* RPAREN */ => ctx.updateTerminal(token, state"4")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseType0Suffix(i: Z): Result = {
    val ctx = Context.create("type0Suffix", u32"0x5DB0F761", ISZ(state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x3D594292" /* OP */ => ctx.updateTerminal(token, state"1")
            case u32"0xFA31AB98" /* SYMBOL */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_type0 = predictType0(ctx.j)
          if (n_type0 >= 0 && parseType0H(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTypeParenArgs(i: Z): Result = {
    val ctx = Context.create("typeParenArgs", u32"0x05831076", ISZ(state"2", state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_type = predictType(ctx.j)
          val n_namedType = predictNamedType(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"1")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_type == n && parseTypeH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_namedType == n && parseNamedTypeH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_commaAnnotType = predictCommaAnnotType(ctx.j)
          if (n_commaAnnotType >= 0 && parseCommaAnnotTypeH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_commaNamedType = predictCommaNamedType(ctx.j)
          if (n_commaNamedType >= 0 && parseCommaNamedTypeH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaAnnotType(i: Z): Result = {
    val ctx = Context.create("commaAnnotType", u32"0xBE6C19DE", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_type = predictType(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"2")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_type == n && parseTypeH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseNamedType(i: Z): Result = {
    val ctx = Context.create("namedType", u32"0xABA54F32", ISZ(state"4"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF20A2856" /* ASSIGN */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_type = predictType(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"3")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_type == n && parseTypeH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"4")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseCommaNamedType(i: Z): Result = {
    val ctx = Context.create("commaNamedType", u32"0x515022D9", ISZ(state"5"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x37DDEF83" /* COMMA */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"2")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0xF20A2856" /* ASSIGN */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_annot = predictAnnot(ctx.j)
          val n_type = predictType(ctx.j)
          for (n <- 2 to 1 by -1 if !ctx.found) {
            if (n_annot == n && parseAnnotH(ctx, state"4")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            } else if (n_type == n && parseTypeH(ctx, state"5")) {
              return Result.error(ctx.isLexical, ctx.failIndex)
            }
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"4" =>
          ctx.found = F
          val n_type = predictType(ctx.j)
          if (n_type >= 0 && parseTypeH(ctx, state"5")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"5" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseType0(i: Z): Result = {
    val ctx = Context.create("type0", u32"0xC89E4B29", ISZ(state"1", state"2"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x0FA8D2E6" /* ID */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_typeArgs = predictTypeArgs(ctx.j)
          if (n_typeArgs >= 0 && parseTypeArgsH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseTypeArgs(i: Z): Result = {
    val ctx = Context.create("typeArgs", u32"0x5C896FFC", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x951E9CFB" /* LSQUARE */ => ctx.updateTerminal(token, state"1")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          val n_typeParenArgs = predictTypeParenArgs(ctx.j)
          if (n_typeParenArgs >= 0 && parseTypeParenArgsH(ctx, state"2")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          token.tipe match {
            case u32"0xA97171F1" /* RSQUARE */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseInterp(i: Z): Result = {
    val ctx = Context.create("interp", u32"0x99E5082E", ISZ(state"1"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          token.tipe match {
            case u32"0x2C97C56A" /* SP */ => ctx.updateTerminal(token, state"1")
            case u32"0x50C3B99F" /* SPB */ => ctx.updateTerminal(token, state"2")
            case u32"0x7E667FD0" /* MSTRP */ => ctx.updateTerminal(token, state"1")
            case u32"0x2427C288" /* MSTRPB */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case state"2" =>
          ctx.found = F
          val n_sinterp = predictSinterp(ctx.j)
          if (n_sinterp >= 0 && parseSinterpH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" =>
          ctx.found = F
          val n_mstrinterp = predictMstrinterp(ctx.j)
          if (n_mstrinterp >= 0 && parseMstrinterpH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseSinterp(i: Z): Result = {
    val ctx = Context.create("sinterp", u32"0x3A86312D", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0xFBA828F9" /* SPM */ => ctx.updateTerminal(token, state"2")
            case u32"0x744EF85A" /* SPE */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_sinterp = predictSinterp(ctx.j)
          if (n_sinterp >= 0 && parseSinterpH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  @pure def parseMstrinterp(i: Z): Result = {
    val ctx = Context.create("mstrinterp", u32"0xC24C785B", ISZ(state"3"), i)

    while (tokens.has(ctx.j)) {
      val token: ParseTree.Leaf = {
        val result = tokens.at(ctx.j)
        if (result.kind != Result.Kind.Normal) {
          return result
        }
        result.leaf
      }
      ctx.state match {
        case state"0" =>
          ctx.found = F
          val n_exp = predictExp(ctx.j)
          if (n_exp >= 0 && parseExpH(ctx, state"1")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"1" =>
          ctx.found = F
          token.tipe match {
            case u32"0x6B6A7ADC" /* MSTRPM */ => ctx.updateTerminal(token, state"2")
            case u32"0x537B19CD" /* MSTRPE */ => ctx.updateTerminal(token, state"3")
            case _ =>
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"2" =>
          ctx.found = F
          val n_mstrinterp = predictMstrinterp(ctx.j)
          if (n_mstrinterp >= 0 && parseMstrinterpH(ctx, state"3")) {
            return Result.error(ctx.isLexical, ctx.failIndex)
          }
          if (!ctx.found) {
            return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
          }
        case state"3" => return retVal(ctx.max, ctx.resOpt, ctx.initial, T)
        case _ => halt("Infeasible")
      }
      if (ctx.max < ctx.j) {
        ctx.max = ctx.j
      }
    }

    return retVal(ctx.j, ctx.resOpt, ctx.initial, T)
  }

  def parseProgramH(ctx: Context, nextState: State): B = {
    val r = parseProgram(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseAnnotH(ctx: Context, nextState: State): B = {
    val r = parseAnnot(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseExpH(ctx: Context, nextState: State): B = {
    val r = parseExp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseStmtH(ctx: Context, nextState: State): B = {
    val r = parseStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseImprtH(ctx: Context, nextState: State): B = {
    val r = parseImprt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseMainMemberH(ctx: Context, nextState: State): B = {
    val r = parseMainMember(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parsePkgH(ctx: Context, nextState: State): B = {
    val r = parsePkg(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseImportIdSuffixH(ctx: Context, nextState: State): B = {
    val r = parseImportIdSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseImportWildcardSuffixH(ctx: Context, nextState: State): B = {
    val r = parseImportWildcardSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseImportQualSuffixH(ctx: Context, nextState: State): B = {
    val r = parseImportQualSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseImportRenamesSuffixH(ctx: Context, nextState: State): B = {
    val r = parseImportRenamesSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseImportRenameH(ctx: Context, nextState: State): B = {
    val r = parseImportRename(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseImportRenameSuffixH(ctx: Context, nextState: State): B = {
    val r = parseImportRenameSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeDefnH(ctx: Context, nextState: State): B = {
    val r = parseTypeDefn(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseModH(ctx: Context, nextState: State): B = {
    val r = parseMod(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseNameH(ctx: Context, nextState: State): B = {
    val r = parseName(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseMemberH(ctx: Context, nextState: State): B = {
    val r = parseMember(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parsePkgSuffixH(ctx: Context, nextState: State): B = {
    val r = parsePkgSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseVarDefnH(ctx: Context, nextState: State): B = {
    val r = parseVarDefn(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseDefDefnH(ctx: Context, nextState: State): B = {
    val r = parseDefDefn(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseInitH(ctx: Context, nextState: State): B = {
    val r = parseInit(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseArgsH(ctx: Context, nextState: State): B = {
    val r = parseArgs(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseRhsH(ctx: Context, nextState: State): B = {
    val r = parseRhs(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseNamedArgH(ctx: Context, nextState: State): B = {
    val r = parseNamedArg(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseArgSuffixH(ctx: Context, nextState: State): B = {
    val r = parseArgSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseNamedArgSuffixH(ctx: Context, nextState: State): B = {
    val r = parseNamedArgSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseNameSuffixH(ctx: Context, nextState: State): B = {
    val r = parseNameSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeParamsH(ctx: Context, nextState: State): B = {
    val r = parseTypeParams(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeDefnEnumSuffixH(ctx: Context, nextState: State): B = {
    val r = parseTypeDefnEnumSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeDefnAliasSuffixH(ctx: Context, nextState: State): B = {
    val r = parseTypeDefnAliasSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeDefnAdtSuffixH(ctx: Context, nextState: State): B = {
    val r = parseTypeDefnAdtSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseEnumMembersH(ctx: Context, nextState: State): B = {
    val r = parseEnumMembers(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeH(ctx: Context, nextState: State): B = {
    val r = parseType(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseParamsH(ctx: Context, nextState: State): B = {
    val r = parseParams(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseSupersH(ctx: Context, nextState: State): B = {
    val r = parseSupers(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeDefnAdtMembersH(ctx: Context, nextState: State): B = {
    val r = parseTypeDefnAdtMembers(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeParamH(ctx: Context, nextState: State): B = {
    val r = parseTypeParam(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeParamSuffixH(ctx: Context, nextState: State): B = {
    val r = parseTypeParamSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaIdH(ctx: Context, nextState: State): B = {
    val r = parseCommaId(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseParamH(ctx: Context, nextState: State): B = {
    val r = parseParam(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaParamsH(ctx: Context, nextState: State): B = {
    val r = parseCommaParams(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseSuprH(ctx: Context, nextState: State): B = {
    val r = parseSupr(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaSuperH(ctx: Context, nextState: State): B = {
    val r = parseCommaSuper(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeArgsH(ctx: Context, nextState: State): B = {
    val r = parseTypeArgs(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseAnnotArgH(ctx: Context, nextState: State): B = {
    val r = parseAnnotArg(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseAnnotArgNestedH(ctx: Context, nextState: State): B = {
    val r = parseAnnotArgNested(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaExpH(ctx: Context, nextState: State): B = {
    val r = parseCommaExp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseColonTypeH(ctx: Context, nextState: State): B = {
    val r = parseColonType(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseAssignSuffixH(ctx: Context, nextState: State): B = {
    val r = parseAssignSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseDefIdH(ctx: Context, nextState: State): B = {
    val r = parseDefId(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseDefParamsH(ctx: Context, nextState: State): B = {
    val r = parseDefParams(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseDefnTypeSuffixH(ctx: Context, nextState: State): B = {
    val r = parseDefnTypeSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseDefParamH(ctx: Context, nextState: State): B = {
    val r = parseDefParam(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseDefParamSuffixH(ctx: Context, nextState: State): B = {
    val r = parseDefParamSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseDefParamSuffixVarargsH(ctx: Context, nextState: State): B = {
    val r = parseDefParamSuffixVarargs(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseExpOrAssignStmtH(ctx: Context, nextState: State): B = {
    val r = parseExpOrAssignStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseVarPatternH(ctx: Context, nextState: State): B = {
    val r = parseVarPattern(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseIfStmtH(ctx: Context, nextState: State): B = {
    val r = parseIfStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseWhileStmtH(ctx: Context, nextState: State): B = {
    val r = parseWhileStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseForStmtH(ctx: Context, nextState: State): B = {
    val r = parseForStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseDeduceStmtH(ctx: Context, nextState: State): B = {
    val r = parseDeduceStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseMatchStmtH(ctx: Context, nextState: State): B = {
    val r = parseMatchStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseDefStmtH(ctx: Context, nextState: State): B = {
    val r = parseDefStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseAssertumeStmtH(ctx: Context, nextState: State): B = {
    val r = parseAssertumeStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseIdStmtH(ctx: Context, nextState: State): B = {
    val r = parseIdStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseExpStmtH(ctx: Context, nextState: State): B = {
    val r = parseExpStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseDoStmtH(ctx: Context, nextState: State): B = {
    val r = parseDoStmt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseIdStmtSuffixH(ctx: Context, nextState: State): B = {
    val r = parseIdStmtSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseLabelSuffixH(ctx: Context, nextState: State): B = {
    val r = parseLabelSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseExp0H(ctx: Context, nextState: State): B = {
    val r = parseExp0(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseAccessH(ctx: Context, nextState: State): B = {
    val r = parseAccess(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseBlockH(ctx: Context, nextState: State): B = {
    val r = parseBlock(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parsePattern0H(ctx: Context, nextState: State): B = {
    val r = parsePattern0(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseColonType1H(ctx: Context, nextState: State): B = {
    val r = parseColonType1(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseElsH(ctx: Context, nextState: State): B = {
    val r = parseEls(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseBlockContentH(ctx: Context, nextState: State): B = {
    val r = parseBlockContent(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseRetH(ctx: Context, nextState: State): B = {
    val r = parseRet(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseElsIfH(ctx: Context, nextState: State): B = {
    val r = parseElsIf(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseForRangeH(ctx: Context, nextState: State): B = {
    val r = parseForRange(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaForRangeH(ctx: Context, nextState: State): B = {
    val r = parseCommaForRange(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseRangeSuffixH(ctx: Context, nextState: State): B = {
    val r = parseRangeSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseIfExpH(ctx: Context, nextState: State): B = {
    val r = parseIfExp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseByExpH(ctx: Context, nextState: State): B = {
    val r = parseByExp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseMatchCasesH(ctx: Context, nextState: State): B = {
    val r = parseMatchCases(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCasH(ctx: Context, nextState: State): B = {
    val r = parseCas(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseIdTypePatternH(ctx: Context, nextState: State): B = {
    val r = parseIdTypePattern(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseWildCardPatternH(ctx: Context, nextState: State): B = {
    val r = parseWildCardPattern(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseWildCardSeqPatternH(ctx: Context, nextState: State): B = {
    val r = parseWildCardSeqPattern(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseLitH(ctx: Context, nextState: State): B = {
    val r = parseLit(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseRefPatternH(ctx: Context, nextState: State): B = {
    val r = parseRefPattern(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parsePatternsH(ctx: Context, nextState: State): B = {
    val r = parsePatterns(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseIdNamePatternH(ctx: Context, nextState: State): B = {
    val r = parseIdNamePattern(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseType1H(ctx: Context, nextState: State): B = {
    val r = parseType1(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parsePatternsArgH(ctx: Context, nextState: State): B = {
    val r = parsePatternsArg(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parsePatternH(ctx: Context, nextState: State): B = {
    val r = parsePattern(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseNamedPatternH(ctx: Context, nextState: State): B = {
    val r = parseNamedPattern(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaPatternH(ctx: Context, nextState: State): B = {
    val r = parseCommaPattern(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaNamedPatternH(ctx: Context, nextState: State): B = {
    val r = parseCommaNamedPattern(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseExp3H(ctx: Context, nextState: State): B = {
    val r = parseExp3(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseForExpH(ctx: Context, nextState: State): B = {
    val r = parseForExp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseDefAnonH(ctx: Context, nextState: State): B = {
    val r = parseDefAnon(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseQuantH(ctx: Context, nextState: State): B = {
    val r = parseQuant(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseExp2H(ctx: Context, nextState: State): B = {
    val r = parseExp2(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseInfixSuffixH(ctx: Context, nextState: State): B = {
    val r = parseInfixSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseInfixOpH(ctx: Context, nextState: State): B = {
    val r = parseInfixOp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseExp1H(ctx: Context, nextState: State): B = {
    val r = parseExp1(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseEtaH(ctx: Context, nextState: State): B = {
    val r = parseEta(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseParenH(ctx: Context, nextState: State): B = {
    val r = parseParen(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseIdExpH(ctx: Context, nextState: State): B = {
    val r = parseIdExp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseThisExpH(ctx: Context, nextState: State): B = {
    val r = parseThisExp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseSuperExpH(ctx: Context, nextState: State): B = {
    val r = parseSuperExp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseInterpH(ctx: Context, nextState: State): B = {
    val r = parseInterp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parsePureBlockH(ctx: Context, nextState: State): B = {
    val r = parsePureBlock(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJsonLitH(ctx: Context, nextState: State): B = {
    val r = parseJsonLit(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseFieldAccessH(ctx: Context, nextState: State): B = {
    val r = parseFieldAccess(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseApplyAccessH(ctx: Context, nextState: State): B = {
    val r = parseApplyAccess(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseFnH(ctx: Context, nextState: State): B = {
    val r = parseFn(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseFnBodyH(ctx: Context, nextState: State): B = {
    val r = parseFnBody(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJsonObjectH(ctx: Context, nextState: State): B = {
    val r = parseJsonObject(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJsonArrayH(ctx: Context, nextState: State): B = {
    val r = parseJsonArray(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJsonParenH(ctx: Context, nextState: State): B = {
    val r = parseJsonParen(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJsonExpH(ctx: Context, nextState: State): B = {
    val r = parseJsonExp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJsonKeyValueH(ctx: Context, nextState: State): B = {
    val r = parseJsonKeyValue(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaJsonKeyValueH(ctx: Context, nextState: State): B = {
    val r = parseCommaJsonKeyValue(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJsonKeyH(ctx: Context, nextState: State): B = {
    val r = parseJsonKey(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJsonH(ctx: Context, nextState: State): B = {
    val r = parseJson(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaJsonH(ctx: Context, nextState: State): B = {
    val r = parseCommaJson(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJsonNullH(ctx: Context, nextState: State): B = {
    val r = parseJsonNull(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseParenArgsH(ctx: Context, nextState: State): B = {
    val r = parseParenArgs(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseNamedExpAnnotH(ctx: Context, nextState: State): B = {
    val r = parseNamedExpAnnot(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaExpAnnotH(ctx: Context, nextState: State): B = {
    val r = parseCommaExpAnnot(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaNamedExpAnnotH(ctx: Context, nextState: State): B = {
    val r = parseCommaNamedExpAnnot(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseQuantRangeH(ctx: Context, nextState: State): B = {
    val r = parseQuantRange(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseIdCommaH(ctx: Context, nextState: State): B = {
    val r = parseIdComma(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseQuantRangeSuffixH(ctx: Context, nextState: State): B = {
    val r = parseQuantRangeSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTruthTableH(ctx: Context, nextState: State): B = {
    val r = parseTruthTable(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseProofH(ctx: Context, nextState: State): B = {
    val r = parseProof(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseSequentH(ctx: Context, nextState: State): B = {
    val r = parseSequent(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseExpProofH(ctx: Context, nextState: State): B = {
    val r = parseExpProof(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseProofStepH(ctx: Context, nextState: State): B = {
    val r = parseProofStep(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseExpsH(ctx: Context, nextState: State): B = {
    val r = parseExps(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseExpJustOptH(ctx: Context, nextState: State): B = {
    val r = parseExpJustOpt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaExpJustOptH(ctx: Context, nextState: State): B = {
    val r = parseCommaExpJustOpt(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJustH(ctx: Context, nextState: State): B = {
    val r = parseJust(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseProofIdH(ctx: Context, nextState: State): B = {
    val r = parseProofId(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseSubProofH(ctx: Context, nextState: State): B = {
    val r = parseSubProof(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseAssumeProofStepH(ctx: Context, nextState: State): B = {
    val r = parseAssumeProofStep(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseAssertProofStepH(ctx: Context, nextState: State): B = {
    val r = parseAssertProofStep(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseFreshIdsH(ctx: Context, nextState: State): B = {
    val r = parseFreshIds(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJustTypeArgsH(ctx: Context, nextState: State): B = {
    val r = parseJustTypeArgs(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseJustArgsH(ctx: Context, nextState: State): B = {
    val r = parseJustArgs(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaTypeH(ctx: Context, nextState: State): B = {
    val r = parseCommaType(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseColonExpH(ctx: Context, nextState: State): B = {
    val r = parseColonExp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseColonIdsH(ctx: Context, nextState: State): B = {
    val r = parseColonIds(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTruthTableConclusionH(ctx: Context, nextState: State): B = {
    val r = parseTruthTableConclusion(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTruthTableCasesH(ctx: Context, nextState: State): B = {
    val r = parseTruthTableCases(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTruthTableCaseH(ctx: Context, nextState: State): B = {
    val r = parseTruthTableCase(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTruthTableAssignmentsH(ctx: Context, nextState: State): B = {
    val r = parseTruthTableAssignments(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTruthTableAssignmentH(ctx: Context, nextState: State): B = {
    val r = parseTruthTableAssignment(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaTruthTableAssignmentH(ctx: Context, nextState: State): B = {
    val r = parseCommaTruthTableAssignment(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeSuffixH(ctx: Context, nextState: State): B = {
    val r = parseTypeSuffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseParenTypeH(ctx: Context, nextState: State): B = {
    val r = parseParenType(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseType0H(ctx: Context, nextState: State): B = {
    val r = parseType0(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseType0SuffixH(ctx: Context, nextState: State): B = {
    val r = parseType0Suffix(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseTypeParenArgsH(ctx: Context, nextState: State): B = {
    val r = parseTypeParenArgs(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseNamedTypeH(ctx: Context, nextState: State): B = {
    val r = parseNamedType(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaAnnotTypeH(ctx: Context, nextState: State): B = {
    val r = parseCommaAnnotType(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseCommaNamedTypeH(ctx: Context, nextState: State): B = {
    val r = parseCommaNamedType(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseSinterpH(ctx: Context, nextState: State): B = {
    val r = parseSinterp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  def parseMstrinterpH(ctx: Context, nextState: State): B = {
    val r = parseMstrinterp(ctx.j)
    r.kind match {
      case Result.Kind.Normal => ctx.updateNonTerminal(r, nextState)
      case Result.Kind.LexicalError =>
        ctx.failIndex = r.newIndex
        ctx.isLexical = T
        return T
      case Result.Kind.GrammaticalError =>
        val index = r.newIndex
        if (index < 0) {
          ctx.failIndex = index
          return T
        } else if (ctx.max < index) {
          ctx.max = index
        }
    }
    return F
  }

  @pure def predictTypeDefnAdtSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x54FAE327" /* COLON */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x702A655E" /* TYPE */ => return 2
                case u32"0xAB02A212" /* TO */ => return 2
                case u32"0xED041C82" /* RBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictDefParams(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictFn(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictBlockContent(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x1E045002" /* DO */ => return 2
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x0E0F65B7" /* WHILE */ => return 2
                case u32"0xBF5AD766" /* FOR */ => return 2
                case u32"0x0FBD9BE6" /* DEDUCE */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0xF5079A9D" /* ASSERT */ => return 2
                case u32"0x02C3896F" /* ASSUME */ => return 2
                case u32"0xD3E917DC" /* RETURN */ => return 2
                case u32"0x37F385AB" /* HALT */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1E045002" /* DO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x18F352F5" /* VAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0E0F65B7" /* WHILE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xBF5AD766" /* FOR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FBD9BE6" /* DEDUCE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x142AC92F" /* MATCH */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xF5079A9D" /* ASSERT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x02C3896F" /* ASSUME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD3E917DC" /* RETURN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x37F385AB" /* HALT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return 0
  }

  @pure def predictIdTypePattern(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTruthTableConclusion(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x951E9CFB" /* LSQUARE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictImportIdSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x9A468353" /* DOT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictIfStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTruthTableCase(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x186E11D7" /* CASE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictIdStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictJustArgs(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictRefPattern(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x9A468353" /* DOT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictWhileStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0E0F65B7" /* WHILE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaExp(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictByExp(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xA7E1A028" /* BY */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictProofStep(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x9A468353" /* DOT */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x9A468353" /* DOT */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaExpAnnot(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictExp0(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ => return 1
        case u32"0x136381C3" /* SUPER */ => return 1
        case u32"0xEE99A672" /* TRUE */ => return 1
        case u32"0x43340E3B" /* FALSE */ => return 1
        case u32"0x589C233C" /* INT */ => return 1
        case u32"0x5028A536" /* HEX */ => return 1
        case u32"0x4E33B13F" /* BIN */ => return 1
        case u32"0x1F9A2C24" /* REAL */ => return 1
        case u32"0xA7CF0FE0" /* STRING */ => return 1
        case u32"0x84A54E6B" /* MSTR */ => return 1
        case u32"0x2C97C56A" /* SP */ => return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ => return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictExp1(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ => return 1
        case u32"0x136381C3" /* SUPER */ => return 1
        case u32"0xEE99A672" /* TRUE */ => return 1
        case u32"0x43340E3B" /* FALSE */ => return 1
        case u32"0x589C233C" /* INT */ => return 1
        case u32"0x5028A536" /* HEX */ => return 1
        case u32"0x4E33B13F" /* BIN */ => return 1
        case u32"0x1F9A2C24" /* REAL */ => return 1
        case u32"0xA7CF0FE0" /* STRING */ => return 1
        case u32"0x84A54E6B" /* MSTR */ => return 1
        case u32"0x2C97C56A" /* SP */ => return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ => return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictExp2(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictExp3(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictType(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x203A34BF" /* ARROW */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictInterp(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x2C97C56A" /* SP */ => return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ => return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictRhs(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0xED041C82" /* RBRACE */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x1E045002" /* DO */ => return 2
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x0E0F65B7" /* WHILE */ => return 2
                case u32"0xBF5AD766" /* FOR */ => return 2
                case u32"0x0FBD9BE6" /* DEDUCE */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0xF5079A9D" /* ASSERT */ => return 2
                case u32"0x02C3896F" /* ASSUME */ => return 2
                case u32"0xD3E917DC" /* RETURN */ => return 2
                case u32"0x37F385AB" /* HALT */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x142AC92F" /* MATCH */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictDefnTypeSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x54FAE327" /* COLON */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictIdExp(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictExpOrAssignStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1E045002" /* DO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaPattern(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictForRange(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xF0D3D2C8" /* UNDERSCORE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictInfixOp(j: Z): Z = {
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ => return 1
        case u32"0xFA31AB98" /* SYMBOL */ => return 1
        case u32"0x5ADD78B7" /* LANGLE */ => return 1
        case u32"0x01420030" /* RANGLE */ => return 1
        case u32"0x15503F3A" /* LRANGLE */ => return 1
        case u32"0x7EF5EC39" /* STAR */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaExpJustOpt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTruthTableCases(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x186E11D7" /* CASE */ => return 2
                case u32"0xED041C82" /* RBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictNameSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x9A468353" /* DOT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictSequent(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x54FAE327" /* COLON */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x611F05DC" /* SEQUENT */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaJson(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x6C774BA6" /* NULL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictImportWildcardSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xF0D3D2C8" /* UNDERSCORE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictJsonExp(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x6C774BA6" /* NULL */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictMember(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x18F352F5" /* VAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x702A655E" /* TYPE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xAB02A212" /* TO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaNamedPattern(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTypeDefnAliasSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xF20A2856" /* ASSIGN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictEta(j: Z): Z = {
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictFreshIds(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictJsonObject(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictJsonParen(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x6C774BA6" /* NULL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictName(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x9A468353" /* DOT */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictDoStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x1E045002" /* DO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaId(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTypeParamSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictExps(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictJsonLit(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictParen(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictQuantRangeSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xAB02A212" /* TO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4F158144" /* UNTIL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictVarDefn(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x18F352F5" /* VAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictPattern(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ => return 1
        case u32"0x43340E3B" /* FALSE */ => return 1
        case u32"0x589C233C" /* INT */ => return 1
        case u32"0x5028A536" /* HEX */ => return 1
        case u32"0x4E33B13F" /* BIN */ => return 1
        case u32"0x1F9A2C24" /* REAL */ => return 1
        case u32"0xA7CF0FE0" /* STRING */ => return 1
        case u32"0x84A54E6B" /* MSTR */ => return 1
        case u32"0x9A468353" /* DOT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xF0D3D2C8" /* UNDERSCORE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x7EF5EC39" /* STAR */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1E045002" /* DO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x18F352F5" /* VAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0E0F65B7" /* WHILE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xBF5AD766" /* FOR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FBD9BE6" /* DEDUCE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x142AC92F" /* MATCH */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xF5079A9D" /* ASSERT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x02C3896F" /* ASSUME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaNamedType(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictAssertProofStep(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xF5079A9D" /* ASSERT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictQuantRange(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTruthTable(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x7EF5EC39" /* STAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0x7566CFCC" /* HLINE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTruthTableAssignments(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictParenArgs(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTypeParam(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictFnBody(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x1E045002" /* DO */ => return 2
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x0E0F65B7" /* WHILE */ => return 2
                case u32"0xBF5AD766" /* FOR */ => return 2
                case u32"0x0FBD9BE6" /* DEDUCE */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0xF5079A9D" /* ASSERT */ => return 2
                case u32"0x02C3896F" /* ASSUME */ => return 2
                case u32"0xD3E917DC" /* RETURN */ => return 2
                case u32"0x37F385AB" /* HALT */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1E045002" /* DO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x18F352F5" /* VAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0E0F65B7" /* WHILE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xBF5AD766" /* FOR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FBD9BE6" /* DEDUCE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x142AC92F" /* MATCH */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xF5079A9D" /* ASSERT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x02C3896F" /* ASSUME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD3E917DC" /* RETURN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x37F385AB" /* HALT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x186E11D7" /* CASE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return 0
  }

  @pure def predictAssumeProofStep(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x02C3896F" /* ASSUME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTypeDefnEnumSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x54FAE327" /* COLON */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictForStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xBF5AD766" /* FOR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictImportRenameSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictImprt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x4B242DB4" /* IMPORT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictSuperExp(j: Z): Z = {
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x136381C3" /* SUPER */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictTypeDefn(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x702A655E" /* TYPE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictFieldAccess(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x9A468353" /* DOT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictMstrinterp(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x6B6A7ADC" /* MSTRPM */ => return 2
                case u32"0x537B19CD" /* MSTRPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictWildCardSeqPattern(j: Z): Z = {
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x7EF5EC39" /* STAR */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictInit(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xAB02A212" /* TO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictJustTypeArgs(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x951E9CFB" /* LSQUARE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictJust(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xA7E1A028" /* BY */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictEls(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x04DDB5EF" /* ELSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictColonIds(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x54FAE327" /* COLON */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictArgSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictExpJustOpt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA7E1A028" /* BY */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictElsIf(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictNamedArgSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaJsonKeyValue(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictIdStmtSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xF20A2856" /* ASSIGN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x54FAE327" /* COLON */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictImportRename(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x203A34BF" /* ARROW */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaTruthTableAssignment(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictExpProof(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictDefStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTypeParenArgs(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x203A34BF" /* ARROW */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictNamedPattern(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictJson(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x951E9CFB" /* LSQUARE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x6C774BA6" /* NULL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x6C774BA6" /* NULL */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictExpStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictIdComma(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictColonType1(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x54FAE327" /* COLON */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictPatternsArg(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x9A468353" /* DOT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xF0D3D2C8" /* UNDERSCORE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x7EF5EC39" /* STAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictSinterp(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFBA828F9" /* SPM */ => return 2
                case u32"0x744EF85A" /* SPE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTypeParams(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x951E9CFB" /* LSQUARE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTruthTableAssignment(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictColonType(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x54FAE327" /* COLON */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictImportQualSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x9A468353" /* DOT */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaForRange(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictColonExp(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x54FAE327" /* COLON */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictSubProof(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictFile(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xFC5CB374" /* EOF */ => return 1
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4B242DB4" /* IMPORT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x1E045002" /* DO */ => return 2
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x0E0F65B7" /* WHILE */ => return 2
                case u32"0xBF5AD766" /* FOR */ => return 2
                case u32"0x0FBD9BE6" /* DEDUCE */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0xF5079A9D" /* ASSERT */ => return 2
                case u32"0x02C3896F" /* ASSUME */ => return 2
                case u32"0x702A655E" /* TYPE */ => return 2
                case u32"0x918F5BDB" /* PACKAGE */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1E045002" /* DO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x18F352F5" /* VAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0E0F65B7" /* WHILE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xBF5AD766" /* FOR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FBD9BE6" /* DEDUCE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x142AC92F" /* MATCH */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xF5079A9D" /* ASSERT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x02C3896F" /* ASSUME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x702A655E" /* TYPE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x918F5BDB" /* PACKAGE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x918F5BDB" /* PACKAGE */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x4B242DB4" /* IMPORT */ => return 2
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x702A655E" /* TYPE */ => return 2
                case u32"0xAB02A212" /* TO */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictDefParamSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xAB02A212" /* TO */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictMod(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTypeDefnAdtMembers(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x702A655E" /* TYPE */ => return 2
                case u32"0xAB02A212" /* TO */ => return 2
                case u32"0xED041C82" /* RBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictJsonArray(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x951E9CFB" /* LSQUARE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x6C774BA6" /* NULL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictNamedArg(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaNamedExpAnnot(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictType0Suffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictDefDefn(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictPureBlock(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictAnnotArg(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictApplyAccess(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0xA5073992" /* RPAREN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictLabelSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x54FAE327" /* COLON */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictJsonKey(j: Z): Z = {
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ => return 1
        case u32"0xA7CF0FE0" /* STRING */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictPattern0(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xEE99A672" /* TRUE */ => return 1
        case u32"0x43340E3B" /* FALSE */ => return 1
        case u32"0x589C233C" /* INT */ => return 1
        case u32"0x5028A536" /* HEX */ => return 1
        case u32"0x4E33B13F" /* BIN */ => return 1
        case u32"0x1F9A2C24" /* REAL */ => return 1
        case u32"0xA7CF0FE0" /* STRING */ => return 1
        case u32"0x84A54E6B" /* MSTR */ => return 1
        case u32"0x9A468353" /* DOT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictWildCardPattern(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xF0D3D2C8" /* UNDERSCORE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictTypeArgs(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x951E9CFB" /* LSQUARE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictImportRenamesSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictVarPattern(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x18F352F5" /* VAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictJsonNull(j: Z): Z = {
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x6C774BA6" /* NULL */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictParams(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictExp(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictAnnotArgNested(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x951E9CFB" /* LSQUARE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictNamedExpAnnot(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictStmtFile(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1E045002" /* DO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x18F352F5" /* VAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0E0F65B7" /* WHILE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xBF5AD766" /* FOR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FBD9BE6" /* DEDUCE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x142AC92F" /* MATCH */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xF5079A9D" /* ASSERT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x02C3896F" /* ASSUME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictArgs(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0xED041C82" /* RBRACE */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x1E045002" /* DO */ => return 2
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x0E0F65B7" /* WHILE */ => return 2
                case u32"0xBF5AD766" /* FOR */ => return 2
                case u32"0x0FBD9BE6" /* DEDUCE */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0xF5079A9D" /* ASSERT */ => return 2
                case u32"0x02C3896F" /* ASSUME */ => return 2
                case u32"0xD3E917DC" /* RETURN */ => return 2
                case u32"0x37F385AB" /* HALT */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x142AC92F" /* MATCH */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictParenType(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictForExp(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictIfExp(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaAnnotType(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaSuper(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCommaType(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictProgram(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4B242DB4" /* IMPORT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x1E045002" /* DO */ => return 2
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x0E0F65B7" /* WHILE */ => return 2
                case u32"0xBF5AD766" /* FOR */ => return 2
                case u32"0x0FBD9BE6" /* DEDUCE */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0xF5079A9D" /* ASSERT */ => return 2
                case u32"0x02C3896F" /* ASSUME */ => return 2
                case u32"0x702A655E" /* TYPE */ => return 2
                case u32"0x918F5BDB" /* PACKAGE */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1E045002" /* DO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x18F352F5" /* VAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0E0F65B7" /* WHILE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xBF5AD766" /* FOR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FBD9BE6" /* DEDUCE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x142AC92F" /* MATCH */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xF5079A9D" /* ASSERT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x02C3896F" /* ASSUME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x702A655E" /* TYPE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x918F5BDB" /* PACKAGE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x918F5BDB" /* PACKAGE */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x4B242DB4" /* IMPORT */ => return 2
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x702A655E" /* TYPE */ => return 2
                case u32"0xAB02A212" /* TO */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return 0
  }

  @pure def predictCommaParams(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x37DDEF83" /* COMMA */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictDefId(j: Z): Z = {
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ => return 1
        case u32"0x3D594292" /* OP */ => return 1
        case u32"0xFA31AB98" /* SYMBOL */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictBlock(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0xED041C82" /* RBRACE */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x1E045002" /* DO */ => return 2
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x0E0F65B7" /* WHILE */ => return 2
                case u32"0xBF5AD766" /* FOR */ => return 2
                case u32"0x0FBD9BE6" /* DEDUCE */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0xF5079A9D" /* ASSERT */ => return 2
                case u32"0x02C3896F" /* ASSUME */ => return 2
                case u32"0xD3E917DC" /* RETURN */ => return 2
                case u32"0x37F385AB" /* HALT */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictDefAnon(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictMainMember(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1E045002" /* DO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x18F352F5" /* VAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8210408E" /* IF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0E0F65B7" /* WHILE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xBF5AD766" /* FOR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FBD9BE6" /* DEDUCE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x142AC92F" /* MATCH */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xF5079A9D" /* ASSERT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x02C3896F" /* ASSUME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x702A655E" /* TYPE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictPkgSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x1E045002" /* DO */ => return 2
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x0E0F65B7" /* WHILE */ => return 2
                case u32"0xBF5AD766" /* FOR */ => return 2
                case u32"0x0FBD9BE6" /* DEDUCE */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0xF5079A9D" /* ASSERT */ => return 2
                case u32"0x02C3896F" /* ASSUME */ => return 2
                case u32"0x702A655E" /* TYPE */ => return 2
                case u32"0xED041C82" /* RBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictMatchCases(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x186E11D7" /* CASE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictRet(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD3E917DC" /* RETURN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case u32"0x37F385AB" /* HALT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictLit(j: Z): Z = {
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xEE99A672" /* TRUE */ => return 1
        case u32"0x43340E3B" /* FALSE */ => return 1
        case u32"0x589C233C" /* INT */ => return 1
        case u32"0x5028A536" /* HEX */ => return 1
        case u32"0x4E33B13F" /* BIN */ => return 1
        case u32"0x1F9A2C24" /* REAL */ => return 1
        case u32"0xA7CF0FE0" /* STRING */ => return 1
        case u32"0x84A54E6B" /* MSTR */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictDefParam(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictJsonKeyValue(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictExpFile(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x93DEEB98" /* THIS */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x136381C3" /* SUPER */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xEE99A672" /* TRUE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x43340E3B" /* FALSE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x589C233C" /* INT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5028A536" /* HEX */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4E33B13F" /* BIN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x1F9A2C24" /* REAL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xA7CF0FE0" /* STRING */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x84A54E6B" /* MSTR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2C97C56A" /* SP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x50C3B99F" /* SPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7E667FD0" /* MSTRP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xFC5CB374" /* EOF */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x5ADD78B7" /* LANGLE */ => return 2
                case u32"0x01420030" /* RANGLE */ => return 2
                case u32"0x15503F3A" /* LRANGLE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xA4512A72" /* QUESTION */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x2427C288" /* MSTRPB */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x26334490" /* BACKTICK */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x49425B4A" /* YIELD */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xCE1D1E69" /* DEF */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictEnumMembers(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictInfixSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x3D594292" /* OP */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x5ADD78B7" /* LANGLE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x01420030" /* RANGLE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x15503F3A" /* LRANGLE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x7EF5EC39" /* STAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictProof(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xDC2A8959" /* LBRACE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0xED041C82" /* RBRACE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictCas(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x186E11D7" /* CASE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictProofId(j: Z): Z = {
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x589C233C" /* INT */ => return 1
        case u32"0xA7CF0FE0" /* STRING */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictSupers(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x54FAE327" /* COLON */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictNamedType(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xF20A2856" /* ASSIGN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictSupr(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictParam(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x18F352F5" /* VAR */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x54FAE327" /* COLON */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictQuant(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x8F29683F" /* ALL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xC21A525C" /* SOME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0xFA31AB98" /* SYMBOL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictPatterns(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0xF0D3D2C8" /* UNDERSCORE */ => return 2
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictAssertumeStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xF5079A9D" /* ASSERT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x02C3896F" /* ASSUME */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictPkg(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x918F5BDB" /* PACKAGE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x4B242DB4" /* IMPORT */ => return 2
                case u32"0x18F352F5" /* VAR */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x702A655E" /* TYPE */ => return 2
                case u32"0xAB02A212" /* TO */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictIdNamePattern(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictAnnot(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xD735687B" /* AT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictAssignSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xF20A2856" /* ASSIGN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictDeduceStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FBD9BE6" /* DEDUCE */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x7EF5EC39" /* STAR */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x54FAE327" /* COLON */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictDefParamSuffixVarargs(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xAB02A212" /* TO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictAccess(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xA4512A72" /* QUESTION */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x9A468353" /* DOT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x9A468353" /* DOT */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0xDC2A8959" /* LBRACE */ => return 2
                case u32"0x8210408E" /* IF */ => return 2
                case u32"0x142AC92F" /* MATCH */ => return 2
                case u32"0x37DDEF83" /* COMMA */ => return 2
                case u32"0xA5073992" /* RPAREN */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictThisExp(j: Z): Z = {
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x93DEEB98" /* THIS */ => return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictMatchStmt(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x142AC92F" /* MATCH */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictType0(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictType1(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x643EF7CD" /* LPAREN */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x0FA8D2E6" /* ID */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case u32"0x951E9CFB" /* LSQUARE */ => return 2
                case _ =>
              }
            }
          }
          return 1
        case _ =>
      }
    }
    return -1
  }

  @pure def predictRangeSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0xAB02A212" /* TO */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case u32"0x4F158144" /* UNTIL */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0x3D594292" /* OP */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case u32"0x93DEEB98" /* THIS */ => return 2
                case u32"0x136381C3" /* SUPER */ => return 2
                case u32"0xEE99A672" /* TRUE */ => return 2
                case u32"0x43340E3B" /* FALSE */ => return 2
                case u32"0x589C233C" /* INT */ => return 2
                case u32"0x5028A536" /* HEX */ => return 2
                case u32"0x4E33B13F" /* BIN */ => return 2
                case u32"0x1F9A2C24" /* REAL */ => return 2
                case u32"0xA7CF0FE0" /* STRING */ => return 2
                case u32"0x84A54E6B" /* MSTR */ => return 2
                case u32"0x2C97C56A" /* SP */ => return 2
                case u32"0x50C3B99F" /* SPB */ => return 2
                case u32"0x7E667FD0" /* MSTRP */ => return 2
                case u32"0x2427C288" /* MSTRPB */ => return 2
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x26334490" /* BACKTICK */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x49425B4A" /* YIELD */ => return 2
                case u32"0xCE1D1E69" /* DEF */ => return 2
                case u32"0x8F29683F" /* ALL */ => return 2
                case u32"0xC21A525C" /* SOME */ => return 2
                case u32"0xFA31AB98" /* SYMBOL */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  @pure def predictTypeSuffix(j: Z): Z = {
    val j1 = j + 1
    val hasJ1 = tokens.has(j1)
    val tokenJ = tokens.at(j)
    if (tokenJ.kind == Result.Kind.Normal) {
      tokenJ.leaf.tipe match {
        case u32"0x203A34BF" /* ARROW */ =>
          if (hasJ1) {
            val tokenJ1 = tokens.at(j1)
            if (tokenJ1.kind == Result.Kind.Normal) {
              tokenJ1.leaf.tipe match {
                case u32"0xD735687B" /* AT */ => return 2
                case u32"0x643EF7CD" /* LPAREN */ => return 2
                case u32"0x0FA8D2E6" /* ID */ => return 2
                case _ =>
              }
            }
          }

        case _ =>
      }
    }
    return -1
  }

  def retVal(n: Z, resOpt: Option[Result], initial: B, noBacktrack: B): Result = {
    resOpt match {
      case Some(res) => return res
      case _ => return Result.error(F, if (noBacktrack && !initial) -n else n)
    }
  }

  @pure def posOpts(docInfo: message.DocInfo,
                    posOpt1: Option[message.Position],
                    posOpt2: Option[message.Position]): Option[message.Position] = {
    val pos1 = posOpt1.get
    val pos2 = posOpt2.get
    return Some(message.PosInfo(docInfo, offsetLength(pos1.offset,
      pos2.offset + pos2.length - pos1.offset)))
  }

}

@datatype class SlangLl2Lexer(cis: Indexable.Pos[C]) {

  def tokenizeAll(skipHidden: B, stopAtError: B, reporter: message.Reporter): ISZ[Result] = {
    var i: Z = 0
    var r = ISZ[Result]()
    var done = F
    while (!done && cis.has(i)) {
      tokenize(i, skipHidden) match {
        case Some(result) =>
          if (result.kind == Result.Kind.Normal) {
            i = result.newIndex
            r = r :+ result
          } else {
            val posOpt = cis.posOpt(i, 1)
            reporter.error(posOpt, kind, s"Could not recognize token")
            if (stopAtError) {
              return r
            }
            r = r :+ result(tree = errorLeaf(text = conversions.String.fromCis(ISZ(cis.at(i))), posOpt = posOpt))
            i = i + 1
          }
        case _ => done = T
      }
    }
    r = r :+ Result.create(eofLeaf, -1)
    return r
  }

  @pure def tokenize(i: Z, skipHidden: B): Option[Result] = {
    val r = MBox(Result.error(T, i))
    tokenizeH(r, i)
    while (skipHidden && r.value.leaf.isHidden && cis.has(r.value.newIndex)) {
      tokenizeH(r, r.value.newIndex)
    }
    return if (skipHidden && r.value.leaf.isHidden) None() else Some(r.value)
  }

  def tokenizeH(r: MBox[Result], i: Z): Unit = {
    updateToken(r, lex_ALL(i))
    updateToken(r, lex_ARROW(i))
    updateToken(r, lex_ASSIGN(i))
    updateToken(r, lex_AT(i))
    updateToken(r, lex_COMMA(i))
    updateToken(r, lex_COLON(i))
    updateToken(r, lex_DOT(i))
    updateToken(r, lex_UNDERSCORE(i))
    updateToken(r, lex_LBRACE(i))
    updateToken(r, lex_LPAREN(i))
    updateToken(r, lex_LSQUARE(i))
    updateToken(r, lex_STAR(i))
    updateToken(r, lex_RBRACE(i))
    updateToken(r, lex_RPAREN(i))
    updateToken(r, lex_RSQUARE(i))
    updateToken(r, lex_SEQUENT(i))
    updateToken(r, lex_SOME(i))
    updateToken(r, lex_TO(i))
    updateToken(r, lex_UNTIL(i))
    updateToken(r, lex_LANGLE(i))
    updateToken(r, lex_RANGLE(i))
    updateToken(r, lex_LRANGLE(i))
    updateToken(r, lex_BACKTICK(i))
    updateToken(r, lex_QUESTION(i))
    updateToken(r, lex_ASSUME(i))
    updateToken(r, lex_ASSERT(i))
    updateToken(r, lex_BY(i))
    updateToken(r, lex_CASE(i))
    updateToken(r, lex_DEDUCE(i))
    updateToken(r, lex_DEF(i))
    updateToken(r, lex_DO(i))
    updateToken(r, lex_FALSE(i))
    updateToken(r, lex_ELSE(i))
    updateToken(r, lex_FOR(i))
    updateToken(r, lex_IF(i))
    updateToken(r, lex_IMPORT(i))
    updateToken(r, lex_MATCH(i))
    updateToken(r, lex_PACKAGE(i))
    updateToken(r, lex_RETURN(i))
    updateToken(r, lex_SUPER(i))
    updateToken(r, lex_THIS(i))
    updateToken(r, lex_TRUE(i))
    updateToken(r, lex_TYPE(i))
    updateToken(r, lex_WHILE(i))
    updateToken(r, lex_YIELD(i))
    updateToken(r, lex_VAR(i))
    updateToken(r, lex_HALT(i))
    updateToken(r, lex_NULL(i))
    updateToken(r, lex_SYMBOL(i))
    updateToken(r, lex_STRING(i))
    updateToken(r, lex_SP(i))
    updateToken(r, lex_SPB(i))
    updateToken(r, lex_SPM(i))
    updateToken(r, lex_SPE(i))
    updateToken(r, lex_MSTR(i))
    updateToken(r, lex_MSTRP(i))
    updateToken(r, lex_MSTRPB(i))
    updateToken(r, lex_MSTRPM(i))
    updateToken(r, lex_MSTRPE(i))
    updateToken(r, lex_ID(i))
    updateToken(r, lex_HLINE(i))
    updateToken(r, lex_OP(i))
    updateToken(r, lex_HEX(i))
    updateToken(r, lex_BIN(i))
    updateToken(r, lex_INT(i))
    updateToken(r, lex_REAL(i))
    updateToken(r, lex_CHAR(i))
    updateToken(r, lex_COMMENT(i))
    updateToken(r, lex_WS(i))
  }

  def updateToken(r: MBox[Result], rOpt: Option[Result]): Unit = {
    rOpt match {
      case Some(newR) if newR.newIndex > r.value.newIndex => r.value = newR
      case _ =>
    }
  }

  @pure def dfa_ALL(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u2200') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_ALL(index: Z): Option[Result] = { return lexH(index, dfa_ALL(index), """ALL""", u32"0x8F29683F", F) }

  @pure def dfa_ARROW(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '=') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '>') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_ARROW(index: Z): Option[Result] = { return lexH(index, dfa_ARROW(index), """ARROW""", u32"0x203A34BF", F) }

  @pure def dfa_ASSIGN(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '=') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_ASSIGN(index: Z): Option[Result] = { return lexH(index, dfa_ASSIGN(index), """ASSIGN""", u32"0xF20A2856", F) }

  @pure def dfa_AT(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '@') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_AT(index: Z): Option[Result] = { return lexH(index, dfa_AT(index), """AT""", u32"0xD735687B", F) }

  @pure def dfa_COMMA(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == ',') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_COMMA(index: Z): Option[Result] = { return lexH(index, dfa_COMMA(index), """COMMA""", u32"0x37DDEF83", F) }

  @pure def dfa_COLON(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == ':') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_COLON(index: Z): Option[Result] = { return lexH(index, dfa_COLON(index), """COLON""", u32"0x54FAE327", F) }

  @pure def dfa_DOT(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '.') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_DOT(index: Z): Option[Result] = { return lexH(index, dfa_DOT(index), """DOT""", u32"0x9A468353", F) }

  @pure def dfa_UNDERSCORE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '_') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_UNDERSCORE(index: Z): Option[Result] = { return lexH(index, dfa_UNDERSCORE(index), """UNDERSCORE""", u32"0xF0D3D2C8", F) }

  @pure def dfa_LBRACE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '{') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_LBRACE(index: Z): Option[Result] = { return lexH(index, dfa_LBRACE(index), """LBRACE""", u32"0xDC2A8959", F) }

  @pure def dfa_LPAREN(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '(') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_LPAREN(index: Z): Option[Result] = { return lexH(index, dfa_LPAREN(index), """LPAREN""", u32"0x643EF7CD", F) }

  @pure def dfa_LSQUARE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '[') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_LSQUARE(index: Z): Option[Result] = { return lexH(index, dfa_LSQUARE(index), """LSQUARE""", u32"0x951E9CFB", F) }

  @pure def dfa_STAR(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '*') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_STAR(index: Z): Option[Result] = { return lexH(index, dfa_STAR(index), """STAR""", u32"0x7EF5EC39", F) }

  @pure def dfa_RBRACE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '}') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_RBRACE(index: Z): Option[Result] = { return lexH(index, dfa_RBRACE(index), """RBRACE""", u32"0xED041C82", F) }

  @pure def dfa_RPAREN(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == ')') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_RPAREN(index: Z): Option[Result] = { return lexH(index, dfa_RPAREN(index), """RPAREN""", u32"0xA5073992", F) }

  @pure def dfa_RSQUARE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == ']') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_RSQUARE(index: Z): Option[Result] = { return lexH(index, dfa_RSQUARE(index), """RSQUARE""", u32"0xA97171F1", F) }

  @pure def dfa_SEQUENT(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '|') {
            ctx.update(state"1")
          } else if (c == '\u22A2') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '-') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_SEQUENT(index: Z): Option[Result] = { return lexH(index, dfa_SEQUENT(index), """SEQUENT""", u32"0x611F05DC", F) }

  @pure def dfa_SOME(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u2203') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_SOME(index: Z): Option[Result] = { return lexH(index, dfa_SOME(index), """SOME""", u32"0xC21A525C", F) }

  @pure def dfa_TO(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '.') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '.') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_TO(index: Z): Option[Result] = { return lexH(index, dfa_TO(index), """TO""", u32"0xAB02A212", F) }

  @pure def dfa_UNTIL(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"3"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '.') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '.') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '<') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_UNTIL(index: Z): Option[Result] = { return lexH(index, dfa_UNTIL(index), """UNTIL""", u32"0x4F158144", F) }

  @pure def dfa_LANGLE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '<') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_LANGLE(index: Z): Option[Result] = { return lexH(index, dfa_LANGLE(index), """LANGLE""", u32"0x5ADD78B7", F) }

  @pure def dfa_RANGLE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '>') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_RANGLE(index: Z): Option[Result] = { return lexH(index, dfa_RANGLE(index), """RANGLE""", u32"0x01420030", F) }

  @pure def dfa_LRANGLE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '<') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '>') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_LRANGLE(index: Z): Option[Result] = { return lexH(index, dfa_LRANGLE(index), """LRANGLE""", u32"0x15503F3A", F) }

  @pure def dfa_BACKTICK(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '`') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_BACKTICK(index: Z): Option[Result] = { return lexH(index, dfa_BACKTICK(index), """BACKTICK""", u32"0x26334490", F) }

  @pure def dfa_QUESTION(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '?') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_QUESTION(index: Z): Option[Result] = { return lexH(index, dfa_QUESTION(index), """QUESTION""", u32"0xA4512A72", F) }

  @pure def dfa_ASSUME(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"6"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'a') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 's') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 's') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'u') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'm') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_ASSUME(index: Z): Option[Result] = { return lexH(index, dfa_ASSUME(index), """ASSUME""", u32"0x02C3896F", F) }

  @pure def dfa_ASSERT(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"6"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'a') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 's') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 's') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'r') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 't') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_ASSERT(index: Z): Option[Result] = { return lexH(index, dfa_ASSERT(index), """ASSERT""", u32"0xF5079A9D", F) }

  @pure def dfa_BY(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'b') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'y') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_BY(index: Z): Option[Result] = { return lexH(index, dfa_BY(index), """BY""", u32"0xA7E1A028", F) }

  @pure def dfa_CASE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"4"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'c') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'a') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 's') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_CASE(index: Z): Option[Result] = { return lexH(index, dfa_CASE(index), """CASE""", u32"0x186E11D7", F) }

  @pure def dfa_DEDUCE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"6"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'd') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'd') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'u') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'c') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_DEDUCE(index: Z): Option[Result] = { return lexH(index, dfa_DEDUCE(index), """DEDUCE""", u32"0x0FBD9BE6", F) }

  @pure def dfa_DEF(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"3"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'd') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'f') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_DEF(index: Z): Option[Result] = { return lexH(index, dfa_DEF(index), """DEF""", u32"0xCE1D1E69", F) }

  @pure def dfa_DO(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'd') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'o') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_DO(index: Z): Option[Result] = { return lexH(index, dfa_DO(index), """DO""", u32"0x1E045002", F) }

  @pure def dfa_FALSE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"5"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'f') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'a') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'l') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 's') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_FALSE(index: Z): Option[Result] = { return lexH(index, dfa_FALSE(index), """FALSE""", u32"0x43340E3B", F) }

  @pure def dfa_ELSE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"4"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'l') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 's') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_ELSE(index: Z): Option[Result] = { return lexH(index, dfa_ELSE(index), """ELSE""", u32"0x04DDB5EF", F) }

  @pure def dfa_FOR(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"3"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'f') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'o') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'r') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_FOR(index: Z): Option[Result] = { return lexH(index, dfa_FOR(index), """FOR""", u32"0xBF5AD766", F) }

  @pure def dfa_IF(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'i') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'f') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_IF(index: Z): Option[Result] = { return lexH(index, dfa_IF(index), """IF""", u32"0x8210408E", F) }

  @pure def dfa_IMPORT(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"6"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'i') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'm') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'p') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'o') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'r') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 't') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_IMPORT(index: Z): Option[Result] = { return lexH(index, dfa_IMPORT(index), """IMPORT""", u32"0x4B242DB4", F) }

  @pure def dfa_MATCH(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"5"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'm') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'a') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 't') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'c') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'h') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_MATCH(index: Z): Option[Result] = { return lexH(index, dfa_MATCH(index), """MATCH""", u32"0x142AC92F", F) }

  @pure def dfa_PACKAGE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"7"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'p') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'a') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'c') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'k') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'a') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'g') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"7")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"7" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_PACKAGE(index: Z): Option[Result] = { return lexH(index, dfa_PACKAGE(index), """PACKAGE""", u32"0x918F5BDB", F) }

  @pure def dfa_RETURN(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"6"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'r') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 't') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'u') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'r') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'n') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_RETURN(index: Z): Option[Result] = { return lexH(index, dfa_RETURN(index), """RETURN""", u32"0xD3E917DC", F) }

  @pure def dfa_SUPER(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"5"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 's') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'u') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'p') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'r') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_SUPER(index: Z): Option[Result] = { return lexH(index, dfa_SUPER(index), """SUPER""", u32"0x136381C3", F) }

  @pure def dfa_THIS(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"4"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 't') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'h') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'i') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 's') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_THIS(index: Z): Option[Result] = { return lexH(index, dfa_THIS(index), """THIS""", u32"0x93DEEB98", F) }

  @pure def dfa_TRUE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"4"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 't') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'r') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'u') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_TRUE(index: Z): Option[Result] = { return lexH(index, dfa_TRUE(index), """TRUE""", u32"0xEE99A672", F) }

  @pure def dfa_TYPE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"4"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 't') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'y') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'p') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_TYPE(index: Z): Option[Result] = { return lexH(index, dfa_TYPE(index), """TYPE""", u32"0x702A655E", F) }

  @pure def dfa_WHILE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"5"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'w') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'h') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'i') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'l') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_WHILE(index: Z): Option[Result] = { return lexH(index, dfa_WHILE(index), """WHILE""", u32"0x0E0F65B7", F) }

  @pure def dfa_YIELD(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"5"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'y') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'i') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'e') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'l') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'd') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_YIELD(index: Z): Option[Result] = { return lexH(index, dfa_YIELD(index), """YIELD""", u32"0x49425B4A", F) }

  @pure def dfa_VAR(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"3"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'v') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'a') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'l' || c == 'r') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_VAR(index: Z): Option[Result] = { return lexH(index, dfa_VAR(index), """VAR""", u32"0x18F352F5", F) }

  @pure def dfa_HALT(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"4"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'h') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'a') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'l') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 't') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_HALT(index: Z): Option[Result] = { return lexH(index, dfa_HALT(index), """HALT""", u32"0x37F385AB", F) }

  @pure def dfa_NULL(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"4"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'n') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'u') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'l') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'l') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" => return ctx.afterAcceptIndex
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_NULL(index: Z): Option[Result] = { return lexH(index, dfa_NULL(index), """NULL""", u32"0x6C774BA6", F) }

  @pure def dfa_SYMBOL(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2", state"3", state"4"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\\') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('A' <= c && c <= 'Z' || c == '_' || 'a' <= c && c <= 'z') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"2")
          } else if (c == '_') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"4")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"2")
          } else if (c == '_') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_SYMBOL(index: Z): Option[Result] = { return lexH(index, dfa_SYMBOL(index), """SYMBOL""", u32"0xFA31AB98", F) }

  @pure def dfa_STRING(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '"') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '!' || '#' <= c && c <= '[' || ']' <= c && c <= maxChar) {
            ctx.update(state"1")
          } else if (c == '"') {
            ctx.update(state"2")
          } else if (c == '\\') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" => return ctx.afterAcceptIndex
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '"' || c == '\'' || c == '\\' || c == 'b' || c == 'f' || c == 'n' || c == 'r' || c == 't') {
            ctx.update(state"1")
          } else if (c == 'u') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"7")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"7" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_STRING(index: Z): Option[Result] = { return lexH(index, dfa_STRING(index), """STRING""", u32"0xA7CF0FE0", F) }

  @pure def dfa_SP(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"3"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('A' <= c && c <= 'Z' || c == '_' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '"') {
            ctx.update(state"2")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          } else if (c == '_') {
            ctx.update(state"10")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '!' || c == '#' || '%' <= c && c <= '[' || ']' <= c && c <= maxChar) {
            ctx.update(state"2")
          } else if (c == '"') {
            ctx.update(state"3")
          } else if (c == '$') {
            ctx.update(state"4")
          } else if (c == '\\') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" => return ctx.afterAcceptIndex
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '"' || c == '\'' || c == '\\' || c == 'b' || c == 'f' || c == 'n' || c == 'r' || c == 't') {
            ctx.update(state"2")
          } else if (c == 'u') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"7")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"7" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"8")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"8" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"9")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"9" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"10" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"11")
          } else if (c == '"') {
            ctx.update(state"2")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          } else if (c == '_') {
            ctx.update(state"10")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"11" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"11")
          } else if (c == '"') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_SP(index: Z): Option[Result] = { return lexH(index, dfa_SP(index), """SP""", u32"0x2C97C56A", F) }

  @pure def dfa_SPB(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"3"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('A' <= c && c <= 'Z' || c == '_' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '"') {
            ctx.update(state"2")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          } else if (c == '_') {
            ctx.update(state"9")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '!' || c == '#' || '%' <= c && c <= '[' || ']' <= c && c <= maxChar) {
            ctx.update(state"2")
          } else if (c == '$') {
            ctx.update(state"3")
          } else if (c == '\\') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '"' || c == '\'' || c == '\\' || c == 'b' || c == 'f' || c == 'n' || c == 'r' || c == 't') {
            ctx.update(state"2")
          } else if (c == 'u') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"7")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"7" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"8")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"8" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"9" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"10")
          } else if (c == '"') {
            ctx.update(state"2")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          } else if (c == '_') {
            ctx.update(state"9")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"10" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"10")
          } else if (c == '"') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_SPB(index: Z): Option[Result] = { return lexH(index, dfa_SPB(index), """SPB""", u32"0x50C3B99F", F) }

  @pure def dfa_SPM(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '!' || c == '#' || '%' <= c && c <= '[' || ']' <= c && c <= maxChar) {
            ctx.update(state"1")
          } else if (c == '$') {
            ctx.update(state"2")
          } else if (c == '\\') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '"' || c == '\'' || c == '\\' || c == 'b' || c == 'f' || c == 'n' || c == 'r' || c == 't') {
            ctx.update(state"1")
          } else if (c == 'u') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"7")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"7" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_SPM(index: Z): Option[Result] = { return lexH(index, dfa_SPM(index), """SPM""", u32"0xFBA828F9", F) }

  @pure def dfa_SPE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '!' || c == '#' || '%' <= c && c <= '[' || ']' <= c && c <= maxChar) {
            ctx.update(state"1")
          } else if (c == '"') {
            ctx.update(state"2")
          } else if (c == '$') {
            ctx.update(state"0")
          } else if (c == '\\') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" => return ctx.afterAcceptIndex
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '"' || c == '\'' || c == '\\' || c == 'b' || c == 'f' || c == 'n' || c == 'r' || c == 't') {
            ctx.update(state"1")
          } else if (c == 'u') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"7")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"7" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_SPE(index: Z): Option[Result] = { return lexH(index, dfa_SPE(index), """SPE""", u32"0x744EF85A", F) }

  @pure def dfa_MSTR(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '#') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0009' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= '#' || '%' <= c && c <= maxChar) {
            ctx.update(state"1")
          } else if (c == '\u000A') {
            ctx.update(state"2")
          } else if (c == '\u000D') {
            ctx.update(state"4")
          } else if (c == '$') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u0009' || c == ' ') {
            ctx.update(state"3")
          } else if (c == '#') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u0009' || c == ' ') {
            ctx.update(state"3")
          } else if (c == '#') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u000A') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_MSTR(index: Z): Option[Result] = { return lexH(index, dfa_MSTR(index), """MSTR""", u32"0x84A54E6B", F) }

  @pure def dfa_MSTRP(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"3"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('A' <= c && c <= 'Z' || c == '_' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '#') {
            ctx.update(state"2")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          } else if (c == '_') {
            ctx.update(state"7")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0009' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= '#' || '%' <= c && c <= maxChar) {
            ctx.update(state"2")
          } else if (c == '\u000A') {
            ctx.update(state"3")
          } else if (c == '\u000D') {
            ctx.update(state"5")
          } else if (c == '$') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u0009' || c == ' ') {
            ctx.update(state"4")
          } else if (c == '#') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u0009' || c == ' ') {
            ctx.update(state"4")
          } else if (c == '#') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u000A') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"7" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"8")
          } else if (c == '#') {
            ctx.update(state"2")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          } else if (c == '_') {
            ctx.update(state"7")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"8" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"8")
          } else if (c == '#') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_MSTRP(index: Z): Option[Result] = { return lexH(index, dfa_MSTRP(index), """MSTRP""", u32"0x7E667FD0", F) }

  @pure def dfa_MSTRPB(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"5"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('A' <= c && c <= 'Z' || c == '_' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '#') {
            ctx.update(state"2")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          } else if (c == '_') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0009' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= '#' || '%' <= c && c <= maxChar) {
            ctx.update(state"2")
          } else if (c == '\u000A') {
            ctx.update(state"3")
          } else if (c == '\u000D') {
            ctx.update(state"4")
          } else if (c == '$') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u0009' || c == ' ') {
            ctx.update(state"3")
          } else if (c == '#') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u000A') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"7")
          } else if (c == '#') {
            ctx.update(state"2")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"1")
          } else if (c == '_') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"7" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"7")
          } else if (c == '#') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_MSTRPB(index: Z): Option[Result] = { return lexH(index, dfa_MSTRPB(index), """MSTRPB""", u32"0x2427C288", F) }

  @pure def dfa_MSTRPM(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"5"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0009' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= '#' || '%' <= c && c <= maxChar) {
            ctx.update(state"1")
          } else if (c == '\u000A') {
            ctx.update(state"2")
          } else if (c == '\u000D') {
            ctx.update(state"4")
          } else if (c == '$') {
            ctx.update(state"0")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u0009' || c == ' ') {
            ctx.update(state"2")
          } else if (c == '#') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0009' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= '#' || '%' <= c && c <= maxChar) {
            ctx.update(state"3")
          } else if (c == '\u000A') {
            ctx.update(state"2")
          } else if (c == '\u000D') {
            ctx.update(state"4")
          } else if (c == '$') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u000A') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_MSTRPM(index: Z): Option[Result] = { return lexH(index, dfa_MSTRPM(index), """MSTRPM""", u32"0x6B6A7ADC", F) }

  @pure def dfa_MSTRPE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1", state"3"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0009' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= '#' || '%' <= c && c <= maxChar) {
            ctx.update(state"2")
          } else if (c == '\u000A') {
            ctx.update(state"3")
          } else if (c == '\u000D') {
            ctx.update(state"4")
          } else if (c == '$') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0009' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= '#' || '%' <= c && c <= maxChar) {
            ctx.update(state"2")
          } else if (c == '\u000A') {
            ctx.update(state"3")
          } else if (c == '\u000D') {
            ctx.update(state"4")
          } else if (c == '$') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" => return ctx.afterAcceptIndex
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u000A') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_MSTRPE(index: Z): Option[Result] = { return lexH(index, dfa_MSTRPE(index), """MSTRPE""", u32"0x537B19CD", F) }

  @pure def dfa_ID(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2", state"3", state"4", state"6"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\'') {
            ctx.update(state"1")
          } else if ('A' <= c && c <= 'Z' || c == '_' || 'a' <= c && c <= 'z') {
            ctx.update(state"2")
          } else if (c == '`') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('A' <= c && c <= 'Z' || c == '_' || 'a' <= c && c <= 'z') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"2")
          } else if (c == '_') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"4")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"2")
          } else if (c == '_') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0008' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= '_' || 'a' <= c && c <= maxChar) {
            ctx.update(state"5")
          } else if (c == '`') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0008' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= '_' || 'a' <= c && c <= maxChar) {
            ctx.update(state"5")
          } else if (c == '`') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_ID(index: Z): Option[Result] = { return lexH(index, dfa_ID(index), """ID""", u32"0x0FA8D2E6", F) }

  @pure def dfa_HLINE(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"5"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '-') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '-') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '-') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '-') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '-') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '-') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_HLINE(index: Z): Option[Result] = { return lexH(index, dfa_HLINE(index), """HLINE""", u32"0x7566CFCC", F) }

  @pure def dfa_OP(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1", state"3", state"4"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"1")
          } else if (c == '\\') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('A' <= c && c <= 'Z' || c == '_' || 'a' <= c && c <= 'z') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"3")
          } else if (c == '_') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"1")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"3")
          } else if (c == '_') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_OP(index: Z): Option[Result] = { return lexH(index, dfa_OP(index), """OP""", u32"0x3D594292", F) }

  @pure def dfa_HEX(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"3"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '0') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'x') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || c == '_' || 'a' <= c && c <= 'f') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_HEX(index: Z): Option[Result] = { return lexH(index, dfa_HEX(index), """HEX""", u32"0x5028A536", F) }

  @pure def dfa_BIN(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"3"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '0') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == 'b') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '1') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '1' || c == '_') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_BIN(index: Z): Option[Result] = { return lexH(index, dfa_BIN(index), """BIN""", u32"0x4E33B13F", F) }

  @pure def dfa_INT(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"2", state"4", state"5", state"6", state"8", state"9"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '-') {
            ctx.update(state"1")
          } else if (c == '0') {
            ctx.update(state"9")
          } else if ('1' <= c && c <= '9') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('1' <= c && c <= '9') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || c == '_') {
            ctx.update(state"2")
          } else if ('A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('A' <= c && c <= 'Z' || c == '_' || 'a' <= c && c <= 'z') {
            ctx.update(state"4")
          } else if (c == '`') {
            ctx.update(state"7")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"4")
          } else if (c == '_') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"6")
          } else if (c == '$' || '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"4")
          } else if (c == '_') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '!' || '%' <= c && c <= '&' || '*' <= c && c <= '+' || c == '-' || c == '/' || c == ':' || '<' <= c && c <= '>' || c == '^' || c == '|' || c == '~' || '\u2200' <= c && c <= '\u22FF' || '\u27C0' <= c && c <= '\u27EF' || '\u2980' <= c && c <= '\u2AFF') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"7" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0008' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= '_' || 'a' <= c && c <= maxChar) {
            ctx.update(state"7")
          } else if (c == '`') {
            ctx.update(state"8")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"8" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0008' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= '_' || 'a' <= c && c <= maxChar) {
            ctx.update(state"7")
          } else if (c == '`') {
            ctx.update(state"8")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"9" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_INT(index: Z): Option[Result] = { return lexH(index, dfa_INT(index), """INT""", u32"0x589C233C", F) }

  @pure def dfa_REAL(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"4", state"5", state"8"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '-') {
            ctx.update(state"1")
          } else if (c == '0') {
            ctx.update(state"9")
          } else if ('1' <= c && c <= '9') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('1' <= c && c <= '9') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '.') {
            ctx.update(state"3")
          } else if ('0' <= c && c <= '9' || c == '_') {
            ctx.update(state"2")
          } else if (c == 'E' || c == 'e') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || c == '_') {
            ctx.update(state"4")
          } else if (c == 'D' || c == 'F' || c == 'd' || c == 'f') {
            ctx.update(state"5")
          } else if (c == 'E' || c == 'e') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" => return ctx.afterAcceptIndex
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '+' || c == '-') {
            ctx.update(state"7")
          } else if ('0' <= c && c <= '9' || c == '_') {
            ctx.update(state"8")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"7" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || c == '_') {
            ctx.update(state"8")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"8" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || c == '_') {
            ctx.update(state"8")
          } else if (c == 'D' || c == 'F' || c == 'd' || c == 'f') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"9" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '.') {
            ctx.update(state"3")
          } else if (c == 'E' || c == 'e') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_REAL(index: Z): Option[Result] = { return lexH(index, dfa_REAL(index), """REAL""", u32"0x1F9A2C24", F) }

  @pure def dfa_CHAR(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"3"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\'') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '&' || '(' <= c && c <= '[' || ']' <= c && c <= maxChar) {
            ctx.update(state"2")
          } else if (c == '\\') {
            ctx.update(state"4")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\'') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" => return ctx.afterAcceptIndex
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '"' || c == '\'' || c == '\\' || c == 'b' || c == 'f' || c == 'n' || c == 'r' || c == 't') {
            ctx.update(state"2")
          } else if (c == 'u') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"7")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"7" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"8")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"8" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"9")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"9" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\'') {
            ctx.update(state"3")
          } else if ('0' <= c && c <= '9' || 'A' <= c && c <= 'F' || 'a' <= c && c <= 'f') {
            ctx.update(state"2")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_CHAR(index: Z): Option[Result] = { return lexH(index, dfa_CHAR(index), """CHAR""", u32"0xE95F063A", F) }

  @pure def dfa_COMMENT(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"5", state"6"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '/') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '*') {
            ctx.update(state"2")
          } else if (c == '/') {
            ctx.update(state"7")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"2" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= ')' || '+' <= c && c <= maxChar) {
            ctx.update(state"2")
          } else if (c == '*') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"3" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= ')' || '+' <= c && c <= '.' || '0' <= c && c <= maxChar) {
            ctx.update(state"2")
          } else if (c == '*') {
            ctx.update(state"4")
          } else if (c == '/') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"4" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= ')' || '+' <= c && c <= '.' || '0' <= c && c <= maxChar) {
            ctx.update(state"2")
          } else if (c == '*') {
            ctx.update(state"3")
          } else if (c == '/') {
            ctx.update(state"5")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"5" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= ')' || '+' <= c && c <= maxChar) {
            ctx.update(state"2")
          } else if (c == '*') {
            ctx.update(state"3")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"6" => return ctx.afterAcceptIndex
        case state"7" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (minChar <= c && c <= '\u0009' || '\u000B' <= c && c <= '\u000C' || '\u000E' <= c && c <= maxChar) {
            ctx.update(state"7")
          } else if (c == '\u000A') {
            ctx.update(state"6")
          } else if (c == '\u000D') {
            ctx.update(state"8")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"8" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if (c == '\u000A') {
            ctx.update(state"6")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_COMMENT(index: Z): Option[Result] = { return lexH(index, dfa_COMMENT(index), """COMMENT""", u32"0x486B464F", T) }

  @pure def dfa_WS(i: Z): Z = {
    val ctx = LContext.create(ISZ(state"1"), i)

    while (cis.has(ctx.j)) {
      ctx.state match {
        case state"0" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('\u0009' <= c && c <= '\u000A' || c == '\u000D' || c == ' ') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case state"1" =>
          val c = cis.at(ctx.j)
          ctx.found = F
          if ('\u0009' <= c && c <= '\u000A' || c == '\u000D' || c == ' ') {
            ctx.update(state"1")
          }
          if (!ctx.found) {
            return ctx.afterAcceptIndex
          }
        case _ => halt("Infeasible")
      }
      ctx.j = ctx.j + 1
    }
    return ctx.afterAcceptIndex
  }

  @pure def lex_WS(index: Z): Option[Result] = { return lexH(index, dfa_WS(index), """WS""", u32"0x0E3F5D1E", T) }

  @pure def hidden(i: Z): Z = {
     var j: Z = -1
     j = dfa_COMMENT(i)
     if (j > 0) {
       return j
     }
     j = dfa_WS(i)
     if (j > 0) {
       return j
     }
     return -1
  }

  @pure def lexH(index: Z, newIndex: Z, name: String, tipe: U32, isHidden: B): Option[Result] = {
    if (newIndex > 0) {
      return Some(Result.create(ParseTree.Leaf(conversions.String.fromCis(for (i <- index until newIndex) yield cis.at(i)),
        name, tipe, isHidden, cis.posOpt(index, newIndex - index)), newIndex))
    } else {
      return None()
    }
  }

}