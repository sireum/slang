<program>          ::=  <package>?
                        import org . sireum . _
                        <stmt>*
                        
<package>          ::=  package <name>

<name>             ::=  <ID> ⸨ . <ID> ⸩*
                   
<stmt>             ::=  <import-stmt>
                     |  <decl-stmt>
                     |  <assign-stmt>
                     |  <block-stmt>
                     |  <if-stmt>
                     |  <match-stmt>
                     |  <while-stmt>
                     |  <for-stmt>
                     |  <return-stmt>
                     |  <exp-stmt>
                     |  <proof-stmt>

<import-stmt>      ::=  import <name> ⸨ . { <import-sel> ⸨ , <import-sel> ⸩* } ⸩?
                     |  import <name> . _

<import-sel>       ::=  <ID>
                     |  <ID> => <ID>

<decl-stmt>        ::=  <val-decl>
                     |  <var-decl>
                     |  <def-decl>
                     |  <enum-decl>
                     |  <object-decl>
                     |  <sig-decl>
                     |  <datatype-decl>
                     |  <record-decl>
                     |  <rich-decl>
                     |  <type-decl>

<val-decl>         ::=  val <ID> ⸨ : <type> ⸩? = <assign-exp>
                     |  @spec val <ID> : <type> = $
                     |  val <pattern> = <assign-exp>

<var-decl>         ::=  var <ID> ⸨ : <type> ⸩? = <assign-exp>
                     |  @spec var <ID> : <type> = $
                     |  var <pattern> = <assign-exp>

<def-decl>         ::=  ⸨ @pure ⸩? def <ID> <type-params>? <params>? : <type>
                     |  ⸨ @pure ⸩? def <ID> <type-params>? <params>? : <type> = <def-body>
                     |  ⸨ @pure ⸩? def <ID> <type-params>? <params>? : <type> = $
                     |  ⸨ @pure ⸩? def <ID> <type-params>? <params>? : <type> = <cdef-contract>
                     |  @spec def <ID> <type-params>? <params>? : <type> = $
                     |  @spec def <ID> <type-params>? <params>? : <type> = <spec-cdef>

<enum-decl>        ::=  @enum object <ID> { <SYMBOL>* }

<object-decl>      ::=  object <ID> <extends>? { <stmt>* }
                     |  @ext object <ID> { <stmt>* }

<sig-decl>         ::=  @sig ⸨ sealed ⸩? trait <ID> <type-params>? <extends>? { <stmt>* }

<datatype-decl>    ::=  @datatype trait <ID> <type-params>? <extends>? { <stmt>* }
                     |  @datatype class <ID> <type-params>? <datatype-params>? <extends>? { <stmt>* }

<record-decl>      ::=  @record trait <ID> <type-params>? <extends>? { <stmt>* }
                     |  @record class <ID> <type-params>? <record-params>? <extends>? { <stmt>* }

<rich-decl>        ::=  @rich trait <ID> <type-params> <extends>? { <stmt>* }
                     |  @rich class <ID> <type-params>? <params>? <extends>? { <stmt>* }

<type-decl>        ::=  type <ID> <type-params>? = <type>

// Notes:
// Built-in basic types: B, <int-type>, F32, F64, R, Unit
// Built-in <int-type>: Z, Z8, Z16, Z32, Z64, N, N8, N16, N32, N64, S8, S16, S32, S64, U8, U16, U32, U64
// Built-in sequences: IS [ <int-type> , <type> ], ISZ [ <type> ], MS [ <int-type> , <type> ], MSZ [ <type> ]

<type>             ::=  <name> <type-args>?
                     |  ( <type> ⸨ , <type> ⸩+ )
                     |  <type> => <type>

<type-args>        ::=  [ <type> ⸨ , <type> ⸩* ]

<assign-exp>       ::=  <exp>
                     |  <block-assign-exp>
                     |  <if-assign-exp>
                     |  <match-assign-exp>

<pattern>          ::=  <lit>
                     |  <ID>
                     |  _
                     |  _*
                     |  ⸨ <ID> @ ⸩? <name> ( <paterns>? )
                     |  ⸨ <ID> @ ⸩? ( <paterns> )

<type-params>      ::=  [ <type-param> ⸨ , <type-param> ⸩* ]

<type-param>       ::=  <ID> ⸨ <: type ⸩?

<params>           ::=  ( ⸨ <param> ⸨ , param> ⸩* ⸩? )

<param>            ::=  ⸨ @pure ⸩? <ID> : <type>

<def-body>         ::=  {
                          <ldef-contract>?
                          <stmt>*
                        }

<extends>          ::=  extends <type> ⸨ with <type> ⸩*

<datatype-params>  ::=  ( ⸨ <datatype-param> ⸨ , <datatype-param> ⸩* ⸩? )

<datatype-param>   ::=  <adt-param-mod>* <ID> : <type>

<adt-param-mod>    ::=  @pure
                     |  @hidden

<record-params>    ::=  ( ⸨ <record-param> ⸨ , <record-param> ⸩* ⸩? )

<record-param>     ::=  <adt-param-mod>* ⸨ var ⸩*  <ID> : <type>

<assign-stmt>      ::=  <lhs> = <assign-exp>
                     |  up ( <lhs> ) = <assign-exp>
                     |  pat ( <pattern> ) = <assign-exp>

<lhs>              ::=  <ID>
                     |  <lhs> . <ID>
                     |  <lhs> ( <exp> )

<if-stmt>          ::=  if ( <exp> ) { <stmt>* } ⸨ else { <stmt>* } ⸩?
                     |  if ( <exp> ) { <stmt>* } else <if-stmt>

<match-stmt>       ::=  <exp> match { <match-case>+ }

<case>             ::=  case <pattern> ⸨ if <exp> ⸩? => <stmt>*

<while-stmt>       ::=  while ( <exp> ) {
                          <loop-contract>?
                          <stmt>*
                        }
                     |  do {
                          <stmt>*
                          <loop-contract>?
                        } while ( <exp> )

<for-stmt>         ::=  for ( <ID> <- <for-range> if <exp> ) {
                          <loop-contract>?
                          <stmt>*
                        }

<for-range>        ::=  <exp>
                     |  <exp> . indices
                     |  <exp> . indices . reverse
                     |  <exp> until <exp> ⸨ by <exp> ⸩?
                     |  <exp> to <exp> ⸨ by <exp> ⸩?

<return-stmt>      ::=  return <exp>?

<proof-stmt>       ::=  l""" <l-stmt> """

<block-assign-exp> ::=  { <stmt>* <exp> }

<if-assign-exp>    ::=  if ( <exp> ) <block-assign-exp> else <block-assign-exp>
                     |  if ( <exp> ) <block-assign-exp> else <if-assign-exp>

<match-assign-exp> ::=  <exp> match { ⸨ <match-case> <exp> ⸩+ }

<exp>              ::=  <lit>
                     |  <STRING-INTERP>
                     |  <name>
                     |  <exp> _
                     |  <unary-op> <exp>
                     |  <exp> <binary-op> <exp>
                     |  ( <exp> ⸨ , <exp> ⸩* )
                     |  <exp> . <ID> <args>?
                     |  <exp> <args>
                     |  if ( <exp> ) <exp> else <exp>
                     |  <quant-op> ID ⸨ , <ID> ⸩* : <domain> <exp>  // only in the proof context

<quant-op>         ::=  ∀
                     |  A
                     |  all
                     |  forall
                     |  ∃
                     |  E
                     |  some
                     |  exists

<domain>           ::=  <type>
                     |  <lrange> <exp> , <exp> <rrange>

<lrange>           ::=  [
                     |  (

<rrange>           ::=  ]
                     |  )

<lit>              ::=  true
                     |  false
                     |  <CHAR>
                     |  <INT>
                     |  <LONG>
                     |  z"<NUM>"
                     |  z8"<NUM>"
                     |  z16"<NUM>"
                     |  z32"<NUM>"
                     |  z64"<NUM>"
                     |  n"<NUM>"
                     |  n8"<NUM>"
                     |  n16"<NUM>"
                     |  n32"<NUM>"
                     |  n64"<NUM>"
                     |  s8"<NUM>"
                     |  s16"<NUM>"
                     |  s32"<NUM>"
                     |  s64"<NUM>"
                     |  u8"<NUM>"
                     |  u16"<NUM>"
                     |  u32"<NUM>"
                     |  u64"<NUM>"
                     |  f32"<FLOAT>"
                     |  f64"<DOUBLE>"
                     |  r"<REAL>"
                     |  bb"<INT>" [ <int-type> ]
                     |  bl"<INT>" [ <int-type> ]
                     |  <FLOAT>
                     |  <DOUBLE>
                     |  <STRING>

<args>             ::=  <type-args>? ( ⸨ <apply-arg> ⸨ , <apply-arg> ⸩* ⸩? )

<apply-arg>        ::=  <exp>
                     |  <exp> -> <exp>
                     |  <ID> = <exp>

// Note: Unicode operators are only available in the proof context

<unary-op>         ::=  +
                     |  -
                     |  ~
                     |  ¬
                     |  !

<binary-op>        ::=  +
                     |  -
                     |  *
                     |  /
                     |  %
                     |  ≡
                     |  ==
                     |  ≠
                     |  !=
                     |  <<
                     |  >>
                     |  >>>
                     |  <
                     |  ≤
                     |  <=
                     |  >
                     |  ≥
                     |  >=
                     |  ∧   // and
                     |  ^   // and
                     |  &   // and
                     |  ∨   // or
                     |  V   // or (i.e., capital V)
                     |  |   // or
                     |  ⊻   // xor
                     |  |^  // xor
                     |  →   // implies, right-associative
                     |  ->  // implies, right-associative, only in the proof context
                     |  :+  // append
                     |  +:  // prepend, right-associative
                     |  ++  // append all
                     |  --  // remove all

<cdef-contract>    ::=  c""" <def-contract> """

<ldef-contract>    ::=  l""" <def-contract> """

<loop-contract>    ::=  l""" <loop-inv-mod> """

<spec-cdef>        ::=  c""" <spec-defs> """

<def-contract>     ::=  ... see https://github.com/sireum/v3/blob/master/slang/shared/src/main/scala/org/sireum/lang/parser/LParser.scala#L384-L397

<spec-defs>        ::=  ... see https://github.com/sireum/v3/blob/master/slang/shared/src/main/scala/org/sireum/lang/parser/LParser.scala#L481-L494

<loop-inv-mod>     ::=  ... see https://github.com/sireum/v3/blob/master/slang/shared/src/main/scala/org/sireum/lang/parser/LParser.scala#L590-L593

<l-clause>         ::=  ... see https://github.com/sireum/v3/blob/master/slang/shared/src/main/scala/org/sireum/lang/parser/LParser.scala#L609-L615
