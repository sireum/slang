main(license, fileUri, packageName, name, preMethod, postMethod, transformHelper, transformMethod) ::= <<
// #Sireum
// @formatter:off

$if(license)$
/*
 $license$
 */

$endif$
$if(fileUri)$
// This file is auto-generated from $fileUri$

$endif$
$if(packageName)$
package $packageName; separator="."$
$endif$

import org.sireum._

object $name$ {

  @record class PreResult[T](continue: B,
                             resultOpt: MOption[T])

  @sig trait PrePost {

    $preMethod; separator="\n\n"$

    $postMethod; separator="\n\n"$

  }

  $transformHelper; separator="\n\n"$

}

import $name$._

@record class $name$(pp: PrePost) {

  $transformMethod; separator="\n\n"$

}
>>

preMethodRoot(typeName, type, preMethodRootCase) ::= <<
def pre$typeName$(o: $type$): PreResult[$type$] = {
  o match {
    $preMethodRootCase; separator="\n"$
  }
}
>>

preMethodRootCase(typeName, type) ::= <<
case o: $type$ => return pre$typeName$(o)
>>

preMethod(typeName, type, superType) ::= <<
def pre$typeName$(o: $type$): PreResult[$superType$] = {
  return PreResult(T, MNone())
}
>>

postMethodRoot(typeName, type, postMethodRootCase) ::= <<
def post$typeName$(o: $type$): MOption[$type$] = {
  o match {
    $postMethodRootCase; separator="\n"$
  }
}
>>

postMethodRootCase(typeName, type) ::= <<
case o: $type$ => return post$typeName$(o)
>>

postMethod(typeName, type, superType) ::= <<
def post$typeName$(o: $type$): MOption[$superType$] = {
  return MNone()
}
>>

transformMethod(typeName, type, transformMethodMatch, preAdapt, postAdapt) ::= <<
def transform$typeName$(o: $type$): MOption[$type$] = {
  val preR: PreResult[$type$] = pp.pre$typeName$(o)$if(preAdapt)$ $preAdapt$$endif$
  val r: MOption[$type$] = if (preR.continue) {
    val o2: $type$ = preR.resultOpt.getOrElse(o)
    val hasChanged: B = preR.resultOpt.nonEmpty
    $transformMethodMatch$
  } else if (preR.resultOpt.nonEmpty) {
    MSome(preR.resultOpt.getOrElse(o))
  } else {
    MNone()
  }
  val hasChanged: B = r.nonEmpty
  val o2: $type$ = r.getOrElse(o)
  val postR: MOption[$type$] = pp.post$typeName$(o2)$if(postAdapt)$ $postAdapt$$endif$
  if (postR.nonEmpty) {
    return postR
  } else if (hasChanged) {
    return MSome(o2)
  } else {
    return MNone()
  }
}
>>

preAdaptDown(type) ::= <<
match {
    case PreResult(continue, MSome(r: $type$)) => PreResult(continue, MSome[$type$](r))
    case _ => assert(F); PreResult(F, MNone[$type$]())
  }
>>

preAdaptUp(type) ::= <<
match {
    case PreResult(continue, MSome(r)) => PreResult(continue, MSome[$type$](r))
    case PreResult(continue, _) => PreResult(continue, MNone[$type$]())
  }
>>

postAdaptDown(type) ::= <<
match {
    case MSome(result: $type$) => MSome[$type$](result)
    case _ => assert(F); MNone[$type$]()
  }
>>

postAdaptUp(type) ::= <<
match {
    case MSome(r) => MSome[$type$](r)
    case _ => MNone[$type$]()
  }
>>

transformMethodMatch(type, transformMethodCase) ::= <<
val rOpt: MOption[$type$] = o2 match {
  $transformMethodCase; separator="\n"$
}
rOpt
>>

transformMethodMatchSimple(transformMethodCaseMember, transformMethodCaseChanged, transformMethodCaseUpdate) ::= <<
$transformMethodCaseMember; separator="\n"$
if (hasChanged$if(transformMethodCaseChanged)$ $transformMethodCaseChanged$$endif$)
  MSome(o2$if(transformMethodCaseUpdate)$($transformMethodCaseUpdate; separator=", "$)$endif$)
else
  MNone()
>>

transformMethodCase(type, transformMethodCaseMember, transformMethodCaseChanged, transformMethodCaseUpdate) ::= <<
case o2: $type$ =>
  $transformMethodCaseMember; separator="\n"$
  if (hasChanged$if(transformMethodCaseChanged)$ $transformMethodCaseChanged$$endif$)
    MSome(o2$if(transformMethodCaseUpdate)$($transformMethodCaseUpdate; separator=", "$)$endif$)
  else
    MNone()
>>

transformMethodCaseMember(i, typeName, type, fieldName) ::= <<
val r$i$: MOption[$type$] = transform$typeName$(o2.$fieldName$)
>>

transformMethodCaseMemberIS(i, indexType, typeName, type, fieldName) ::= <<
val r$i$: MOption[IS[$indexType$, $type$]] = transformIS$indexType$(o2.$fieldName$, transform$typeName$ _)
>>

transformMethodCaseMemberMS(i, indexType, typeName, type, fieldName) ::= <<
val r$i$: MOption[MS[$indexType$, $type$]] = transformMS$indexType$(o2.$fieldName$, transform$typeName$ _)
>>

transformMethodCaseMemberOption(i, typeName, type, fieldName) ::= <<
val r$i$: MOption[Option[$type$]] = transformOption(o2.$fieldName$, transform$typeName$ _)
>>

transformMethodCaseMemberMOption(i, typeName, type, fieldName) ::= <<
val r$i$: MOption[MOption[$type$]] = transformOption(o2.$fieldName$, transform$typeName$ _)
>>

transformMethodCaseChanged(i) ::= <<
| r$i$.nonEmpty
>>

transformMethodCaseUpdate(i, fieldName) ::= <<
$fieldName$ = r$i$.getOrElse(o2.$fieldName$)
>>

transformOption() ::= <<
def transformOption[T](option: Option[T], f: T => MOption[T]): MOption[Option[T]] = {
  option match {
    case Some(v) =>
      val r = f(v)
      r match {
        case MSome(v2) => return MSome(Some(v2))
        case _ => return MNone()
      }
    case _ => return MNone()
  }
}
>>

transformMOption() ::= <<
def transformMOption[T](option: MOption[T], f: T => MOption[T]): MOption[MOption[T]] = {
  option match {
    case MSome(v) =>
      val r = f(v)
      r match {
        case MSome(_) => return MSome(r)
        case _ => return MNone()
      }
    case _ => return MNone()
  }
}
>>

transformIS(indexType) ::= <<
def transformIS$indexType$[T](s: IS[$indexType$, T], f: T => MOption[T]): MOption[IS[$indexType$, T]] = {
  val s2: MS[$indexType$, T] = SI.toMS(s)
  var changed: B = F
  for (i <- s2.indices) {
    val e: T = s(i)
    val r: MOption[T] = f(e)
    changed = changed | r.nonEmpty
    s2(i) = r.getOrElse(e)
  }
  if (changed) {
    return MSome(SM.toIS(s2))
  } else {
    return MNone()
  }
}
>>

transformMS(indexType) ::= <<
def transformIS$indexType$[T](s: IS[$indexType$, T], f: T => MOption[T]): MOption[IS[$indexType$, T]] = {
  var s2: MS[$indexType$, T] = MS[Z, T]()
  var changed: B = F
  for (i <- s2.indices) {
    val e: T = s(i)
    val r: MOption[T] = f(e)
    changed = changed | r.nonEmpty
    s2 = s2 :+ r.getOrElse(e)
  }
  if (changed) {
    return MSome(s2)
  } else {
    return MNone()
  }
}
>>