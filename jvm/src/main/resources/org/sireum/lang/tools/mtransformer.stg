main(license, fileUri, packageName, name, preMethod, postMethod, transformHelper, transformMethod) ::= <<
// #Sireum
// @formatter:off

$if(license)$
/*
 $license$
 */

$endif$
$if(fileUri)$
// This file is auto-generated from $fileUri$

$endif$
$if(packageName)$
package $packageName; separator="."$
$endif$

import org.sireum._

object $name$ {

  @datatype class PreResult[T](continue: B,
                               resultOpt: Option[T])

  @sig trait Pre {

    $preMethod; separator="\n\n"$

  }

  @sig trait Post {

    $postMethod; separator="\n\n"$

  }

  $transformHelper; separator="\n\n"$

}

import $name$._

@record class $name$(pre: Pre, post: Post) {

  $transformMethod; separator="\n\n"$

}
>>

preMethodRoot(typeName, type, preMethodRootCase) ::= <<
def transform$typeName$(o: $type$): PreResult[$type$] = {
  o match {
    $preMethodRootCase; separator="\n"$
  }
}
>>

preMethodRootCase(typeName, type) ::= <<
case o: $type$ => return transform$typeName$(o)
>>

preMethod(typeName, type, superType) ::= <<
def transform$typeName$(o: $type$): PreResult[$superType$] = {
  return PreResult(T, None())
}
>>

postMethodRoot(typeName, type, postMethodRootCase) ::= <<
def transform$typeName$(o: $type$): Option[$type$] = {
  o match {
    $postMethodRootCase; separator="\n"$
  }
}
>>

postMethodRootCase(typeName, type) ::= <<
case o: $type$ => return transform$typeName$(o)
>>

postMethod(typeName, type, superType) ::= <<
def transform$typeName$(o: $type$): Option[$superType$] = {
  return None()
}
>>

transformMethod(typeName, type, transformMethodMatch, preAdapt, postAdapt) ::= <<
def transform$typeName$(o: $type$): Option[$type$] = {
  val preR: PreResult[$type$] = pre.transform$typeName$(o)$if(preAdapt)$ $preAdapt$$endif$
  val r: Option[$type$] = if (preR.continue) {
    val o2: $type$ = preR.resultOpt.getOrElse(o)
    val hasChanged: B = preR.resultOpt.nonEmpty
    $transformMethodMatch$
  } else if (preR.resultOpt.nonEmpty) {
    Some(preR.resultOpt.getOrElse(o))
  } else {
    None()
  }
  val hasChanged: B = r.nonEmpty
  val o2: $type$ = r.getOrElse(o)
  val postR: Option[$type$] = post.transform$typeName$(o2)$if(postAdapt)$ $postAdapt$$endif$
  if (postR.nonEmpty) {
    return postR
  } else if (hasChanged) {
    return Some(o2)
  } else {
    return None()
  }
}
>>

preAdaptDown(type) ::= <<
match {
    case PreResult(continue, Some(r: $type$)) => PreResult(continue, Some[$type$](r))
    case _ => assert(F); PreResult(F, None[$type$]())
  }
>>

preAdaptUp(type) ::= <<
match {
    case PreResult(continue, Some(r)) => PreResult(continue, Some[$type$](r))
    case PreResult(continue, _) => PreResult(continue, None[$type$]())
  }
>>

postAdaptDown(type) ::= <<
match {
    case Some(result: $type$) => Some[$type$](result)
    case _ => assert(F); None[$type$]()
  }
>>

postAdaptUp(type) ::= <<
match {
    case Some(r) => Some[$type$](r)
    case _ => None[$type$]()
  }
>>

transformMethodMatch(type, transformMethodCase) ::= <<
val rOpt: Option[$type$] = o2 match {
  $transformMethodCase; separator="\n"$
}
rOpt
>>

transformMethodMatchSimple(transformMethodCaseMember, transformMethodCaseChanged, transformMethodCaseUpdate) ::= <<
$transformMethodCaseMember; separator="\n"$
if (hasChanged$if(transformMethodCaseChanged)$ $transformMethodCaseChanged$$endif$)
  Some(o2$if(transformMethodCaseUpdate)$($transformMethodCaseUpdate; separator=", "$)$endif$)
else
  None()
>>

transformMethodCase(type, transformMethodCaseMember, transformMethodCaseChanged, transformMethodCaseUpdate) ::= <<
case o2: $type$ =>
  $transformMethodCaseMember; separator="\n"$
  if (hasChanged$if(transformMethodCaseChanged)$ $transformMethodCaseChanged$$endif$)
    Some(o2$if(transformMethodCaseUpdate)$($transformMethodCaseUpdate; separator=", "$)$endif$)
  else
    None()
>>

transformMethodCaseMember(i, typeName, type, fieldName) ::= <<
val r$i$: Option[$type$] = transform$typeName$(o2.$fieldName$)
>>

transformMethodCaseMemberIS(i, indexType, typeName, type, fieldName) ::= <<
val r$i$: Option[IS[$indexType$, $type$]] = transformIS$indexType$(o2.$fieldName$, transform$typeName$ _)
>>

transformMethodCaseMemberMS(i, indexType, typeName, type, fieldName) ::= <<
val r$i$: Option[MS[$indexType$, $type$]] = transformMS$indexType$(o2.$fieldName$, transform$typeName$ _)
>>

transformMethodCaseMemberOption(i, typeName, type, fieldName) ::= <<
val r$i$: Option[Option[$type$]] = transformOption(o2.$fieldName$, transform$typeName$ _)
>>

transformMethodCaseChanged(i) ::= <<
| r$i$.nonEmpty
>>

transformMethodCaseUpdate(i, fieldName) ::= <<
$fieldName$ = r$i$.getOrElse(o2.$fieldName$)
>>

transformOption() ::= <<
def transformOption[T](option: Option[T], f: T => Option[T]): Option[Option[T]] = {
  option match {
    case Some(v) =>
      val r = f(v)
      r match {
        case Some(_) => return Some(r)
        case _ => return None()
      }
    case _ => return None()
  }
}
>>

transformIS(indexType) ::= <<
def transformIS$indexType$[T](s: IS[$indexType$, T], f: T => Option[T]): Option[IS[$indexType$, T]] = {
  val s2: MS[$indexType$, T] = SI.toMS(s)
  var changed: B = F
  for (i <- s2.indices) {
    val e: T = s(i)
    val r: Option[T] = f(e)
    changed = changed | r.nonEmpty
    s2(i) = r.getOrElse(e)
  }
  if (changed) {
    return Some(SM.toIS(s2))
  } else {
    return None()
  }
}
>>

transformMS(indexType) ::= <<
def transformIS$indexType$[T](s: IS[$indexType$, T], f: T => Option[T]): Option[IS[$indexType$, T]] = {
  var s2: MS[$indexType$, T] = MS[Z, T]()
  var changed: B = F
  for (i <- s2.indices) {
    val e: T = s(i)
    val r: Option[T] = f(e)
    changed = changed | r.nonEmpty
    s2 = s2 :+ r.getOrElse(e)
  }
  if (changed) {
    return Some(s2)
  } else {
    return None()
  }
}
>>